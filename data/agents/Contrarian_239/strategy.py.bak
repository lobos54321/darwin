import random
import statistics
import math
from collections import deque

class MyStrategy:
    """
    Agent: Contrarian_239 -> Evolved: Darwin_Hybrid_v2
    
    ðŸ§¬ Evolution Report:
    1.  **Inherited Winner DNA (Phoenix)**: 
        - Adopted RSI (14) to filter 'falling knives' (only buy when oversold).
        - Implemented 'Tick Up' confirmation (current > prev) to ensure price stabilization before entry.
    
    2.  **New Mutation - Dynamic Volatility Sizing**: 
        - Instead of fixed sizing, position size is inversely proportional to volatility (Standard Deviation). 
        - High Volatility = Smaller Size (Protect Capital). Low Volatility = Larger Size (Capture Alpha).
    
    3.  **New Mutation - Hard Risk Floor**: 
        - Implemented a strict 4% Stop Loss per trade to prevent the previous -46% drawdown.
        - Added a 'Time-out' mechanism: if a position is held too long without profit, force close to free liquidity.
    """

    def __init__(self):
        print("ðŸ§  Strategy Initialized (Darwin_Hybrid_v2: RSI-Bollinger + Volatility Sizing)")
        
        # --- Parameters ---
        self.lookback_period = 20       # Bollinger Band Period
        self.rsi_period = 14            # RSI Period
        self.z_entry_threshold = -2.0   # Buy below -2 StdDev
        self.rsi_oversold = 35          # RSI threshold for buying
        self.rsi_overbought = 70        # RSI threshold for selling
        self.stop_loss_pct = 0.04       # 4% Hard Stop Loss
        self.max_hold_ticks = 20        # Max time to hold a stagnant position
        
        # --- State ---
        self.history = {}               # {symbol: deque([prices], maxlen=30)}
        self.positions = {}             # {symbol: {'entry': float, 'ticks': int}}
        self.prev_prices = {}           # To track tick-up logic

    def calculate_rsi(self, prices, period=14):
        """Standard RSI Calculation"""
        if len(prices) < period + 1:
            return 50 # Neutral default
            
        gains = []
        losses = []
        
        for i in range(1, len(prices)):
            delta = prices[i] - prices[i-1]
            if delta > 0:
                gains.append(delta)
                losses.append(0)
            else:
                gains.append(0)
                losses.append(abs(delta))
        
        # Simple Average for performance (EMA is better but SMA is robust enough here)
        avg_gain = sum(gains[-period:]) / period
        avg_loss = sum(losses[-period:]) / period
        
        if avg_loss == 0:
            return 100
            
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))

    def get_volatility_size(self, balance, std_dev, price):
        """
        Mutation: Adjust trade size based on volatility.
        Higher StdDev relative to price = Smaller Position.
        """
        if price == 0: return 0
        
        rel_vol = std_dev / price # Relative volatility percentage
        
        # Base sizing: 20% of capital
        base_size = balance * 0.20
        
        # Dampener: If volatility is high (>2%), reduce size
        if rel_vol > 0.02:
            multiplier = 0.02 / rel_vol
            return base_size * multiplier
        
        return base_size

    def next_action(self, current_prices, balance):
        """
        Called every tick. Returns (action, symbol, amount).
        """
        # 1. Update History
        for sym, price in current_prices.items():
            if sym not in self.history:
                self.history[sym] = deque(maxlen=self.lookback_period + 5)
            self.history[sym].append(price)

        # 2. Manage Existing Positions (Exit Logic)
        for sym in list(self.positions.keys()):
            pos_data = self.positions[sym]
            entry_price = pos_data['entry']
            current_price = current_prices[sym]
            pos_data['ticks'] += 1
            
            # A. Hard Stop Loss (Priority 1)
            if current_price < entry_price * (1 - self.stop_loss_pct):
                del self.positions[sym]
                return "SELL", sym, 1.0 # Sell all
            
            # B. Time Decay Exit (Priority 2)
            # If held long and barely profitable or losing, cut it
            if pos_data['ticks'] > self.max_hold_ticks:
                if current_price < entry_price * 1.01: # Less than 1% profit after long hold
                    del self.positions[sym]
                    return "SELL", sym, 1.0
            
            # C. Technical Exit (Mean Reversion / RSI Overbought)
            if len(self.history[sym]) >= self.lookback_period:
                hist = list(self.history[sym])
                rsi = self.calculate_rsi(hist, self.rsi_period)
                sma = statistics.mean(hist[-self.lookback_period:])
                
                # Sell if price returns to Mean OR RSI gets hot
                if current_price > sma or rsi > self.rsi_overbought:
                    del self.positions[sym]
                    return "SELL", sym, 1.0

        # 3. Scan for New Entries (Entry Logic)
        if balance < 10: # Minimum cash guard
            return "WAIT", None, 0

        candidates = []
        
        for sym, price in current_prices.items():
            if sym in self.positions: continue # Already hold
            if len(self.history[sym]) < self.lookback_period: continue
            
            hist = list(self.history[sym])
            sma = statistics.mean(hist)
            std = statistics.stdev(hist)
            
            if std == 0: continue
            
            z_score = (price - sma) / std
            rsi = self.calculate_rsi(hist, self.rsi_period)
            
            # Check Winner's Logic: Tick Up Confirmation
            # Only buy if current price > previous price (Green Candle)
            prev_price = hist[-2] if len(hist) >= 2 else price
            tick_up = price > prev_price
            
            # --- SIGNAL GENERATION ---
            # 1. Price is statistically cheap (Z < -2)
            # 2. Asset is oversold (RSI < 35)
            # 3. Price is showing signs of life (Tick Up)
            if z_score < self.z_entry_threshold and rsi < self.rsi_oversold and tick_up:
                candidates.append((sym, std))

        # 4. Execute Trade
        if candidates:
            # Pick the one with best setup (random choice among valid candidates to avoid overfitting)
            target_sym, target_std = random.choice(candidates)
            current_p = current_prices[target_sym]
            
            # Calculate Dynamic Size
            trade_value = self.get_volatility_size(balance, target_std, current_p)
            amount = trade_value / current_p
            
            self.positions[target_sym] = {'entry': current_p, 'ticks': 0}
            return "BUY", target_sym, amount

        return "WAIT", None, 0