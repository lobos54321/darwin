# Darwin SDK - User Strategy Template
# ðŸ§  DEVELOPERS: EDIT THIS FILE ONLY!

import random
import math
from collections import deque
import statistics

class MyStrategy:
    """
    Agent: Contrarian_239 -> Evolved: Phoenix_Ascending_v1
    
    ðŸ§¬ Evolution Summary:
    1.  **Winner's Essence (Momentum)**: Fully embraced momentum but discarded simple price-change logic. Now uses an EMA Crossover system to detect genuine trend shifts.
    2.  **Mutation (Volatility Filter)**: Added a Standard Deviation (Volatility) filter. We only enter momentum trades when volatility is expanding (breakout), avoiding the "chop" that killed the previous version.
    3.  **Dynamic Risk Management**: Replaced static 5% stops with ATR-based dynamic trailing stops. Tighter stops in calm markets, looser in volatile ones to prevent premature shakeouts.
    """

    def __init__(self):
        print("ðŸ§  Strategy Initialized (Phoenix_Ascending_v1)")
        
        # --- Genome / Hyperparameters ---
        self.FAST_WINDOW = 7            # Fast Moving Average
        self.SLOW_WINDOW = 21           # Slow Moving Average (Trend Baseline)
        self.VOL_WINDOW = 14            # Volatility Calculation Window
        self.ATR_MULTIPLIER = 2.5       # Trailing Stop distance (x Volatility)
        self.MAX_POSITIONS = 3          # Concentration penalty avoidance
        
        # --- State Tracking ---
        self.history = {}               # {symbol: deque(maxlen=30)}
        self.positions = {}             # {symbol: {'entry_price': float, 'highest_price': float, 'vol_at_entry': float}}
        self.banned_tags = set()
        self.cooldowns = {}             # {symbol: int (ticks remaining)}

    def on_hive_signal(self, signal: dict):
        """Adapt to Hive Mind penalties"""
        penalize = signal.get("penalize", [])
        if penalize:
            self.banned_tags.update(penalize)

    def _calculate_indicators(self, prices):
        """Helper to get SMA and StdDev"""
        if len(prices) < self.SLOW_WINDOW:
            return None, None, None
        
        current_price = prices[-1]
        fast_ma = statistics.mean(list(prices)[-self.FAST_WINDOW:])
        slow_ma = statistics.mean(list(prices)[-self.SLOW_WINDOW:])
        
        # Calculate Volatility (Standard Deviation of recent returns)
        if len(prices) >= self.VOL_WINDOW:
            vol = statistics.stdev(list(prices)[-self.VOL_WINDOW:])
        else:
            vol = 0.0
            
        return fast_ma, slow_ma, vol

    def on_price_update(self, prices: dict):
        """
        Main Trading Logic Loop
        """
        orders = []
        
        for symbol, data in prices.items():
            current_price = data["priceUsd"]
            
            # 1. Update Data Feeds
            if symbol not in self.history:
                self.history[symbol] = deque(maxlen=self.SLOW_WINDOW + 5)
            self.history[symbol].append(current_price)
            
            # Handle Cooldowns
            if symbol in self.cooldowns:
                self.cooldowns[symbol] -= 1
                if self.cooldowns[symbol] <= 0:
                    del self.cooldowns[symbol]
                continue

            # Need enough history to make a decision
            if len(self.history[symbol]) < self.SLOW_WINDOW:
                continue

            # 2. Calculate Indicators
            fast_ma, slow_ma, volatility = self._calculate_indicators(self.history[symbol])
            if fast_ma is None:
                continue

            # 3. Manage Existing Positions (Exit Logic)
            if symbol in self.positions:
                pos = self.positions[symbol]
                
                # Update High Water Mark
                if current_price > pos['highest_price']:
                    pos['highest_price'] = current_price
                
                # Dynamic Trailing Stop Calculation
                # Stop moves up as price moves up, but distance depends on volatility
                stop_distance = max(volatility * self.ATR_MULTIPLIER, current_price * 0.02) # Min 2% buffer
                stop_price = pos['highest_price'] - stop_distance
                
                # EXIT: Trailing Stop Hit OR Trend Reversal (Fast crosses below Slow)
                is_stop_loss = current_price < stop_price
                is_trend_reversal = fast_ma < slow_ma
                
                if is_stop_loss or is_trend_reversal:
                    reason = "Trailing Stop" if is_stop_loss else "Trend Reversal"
                    # print(f"ðŸ“‰ SELL {symbol} at {current_price} ({reason})")
                    orders.append({"symbol": symbol, "side": "sell", "amount": 1.0})
                    del self.positions[symbol]
                    self.cooldowns[symbol] = 5 # Wait 5 ticks before re-entering
                
                continue # Skip entry logic if we hold position

            # 4. Entry Logic (Momentum + Volatility Expansion)
            # Only enter if we have room
            if len(self.positions) >= self.MAX_POSITIONS:
                continue
                
            # Filter: Ignore assets with negative 24h change (Trend alignment)
            if data.get("priceChange24h", 0) < 0:
                continue

            # SIGNAL: Golden Cross (Fast > Slow) AND Price is above Slow MA
            # MUTATION: Ensure volatility is sufficient (price is moving) to cover fees
            is_uptrend = fast_ma > slow_ma and current_price > slow_ma
            is_active = volatility > (current_price * 0.005) # Volatility > 0.5% of price
            
            if is_uptrend and is_active:
                # print(f"ðŸš€ BUY {symbol} at {current_price} (Breakout)")
                self.positions[symbol] = {
                    'entry_price': current_price,
                    'highest_price': current_price,
                    'vol_at_entry': volatility
                }
                orders.append({"symbol": symbol, "side": "buy", "amount": 1.0})

        return orders