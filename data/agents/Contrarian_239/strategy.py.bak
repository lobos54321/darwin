import random
import statistics
import math
from collections import deque

class MyStrategy:
    """
    Agent: Contrarian_239_Gen13 "Phoenix_Ascendant"
    
    ðŸ§¬ Evolution Log:
    1.  **Winner Integration (Phoenix DNA)**: Adopted 'Tick Up' confirmation and RSI oversold checks to avoid falling knives.
    2.  **Mutation (Regime Switching)**: 
        - Instead of a single logic, we calculate Relative Volatility (ATR/Price).
        - Low Volatility -> Mean Reversion (Buy Lower BB).
        - High Volatility -> Momentum (Buy Upper BB Breakout).
    3.  **Risk Management Overhaul**: 
        - Reduced base risk from 5% to 2% to stop the bleeding.
        - Implemented a 'Ratchet Trailing Stop' to lock in profits immediately.
    4.  **Portfolio Heat Control**: Max 5 open positions to prevent over-exposure.
    """

    def __init__(self):
        self.history = {}          # {symbol: deque(maxlen=100)}
        self.positions = {}        # {symbol: {'entry_price': float, 'size': float, 'stop_loss': float, 'highest_price': float}}
        self.balance = 536.69      # Sync with current state
        self.initial_balance = 536.69
        
        # Hyperparameters
        self.max_history = 100
        self.rsi_period = 14
        self.bb_period = 20
        self.bb_std_dev = 2.0
        self.risk_per_trade = 0.02 # Reduced to 2% to preserve capital
        self.max_positions = 5
        
    def calculate_rsi(self, prices, period=14):
        if len(prices) < period + 1:
            return 50.0
        
        gains = []
        losses = []
        for i in range(1, len(prices)):
            delta = prices[i] - prices[i-1]
            if delta > 0:
                gains.append(delta)
                losses.append(0)
            else:
                gains.append(0)
                losses.append(abs(delta))
        
        # Simple average for the first step (simplified for speed/robustness)
        avg_gain = sum(gains[-period:]) / period
        avg_loss = sum(losses[-period:]) / period
        
        if avg_loss == 0:
            return 100.0
        
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))

    def get_bollinger_bands(self, prices, period=20, num_std=2.0):
        if len(prices) < period:
            return None, None, None
        
        recent_prices = list(prices)[-period:]
        sma = statistics.mean(recent_prices)
        std_dev = statistics.stdev(recent_prices)
        
        upper = sma + (std_dev * num_std)
        lower = sma - (std_dev * num_std)
        return upper, sma, lower

    def get_atr(self, prices, period=14):
        if len(prices) < period + 1:
            return 0.0
        
        tr_list = []
        # Calculate True Range for the available history
        prices_list = list(prices)
        for i in range(1, len(prices_list)):
            high = prices_list[i] # Assuming close as high proxy in simple feed
            low = prices_list[i]  # Assuming close as low proxy in simple feed
            prev_close = prices_list[i-1]
            # Simplified TR: abs(current - prev)
            tr = abs(prices_list[i] - prev_close)
            tr_list.append(tr)
            
        if not tr_list:
            return 0.0
            
        return sum(tr_list[-period:]) / period

    def next_tick(self, tick_data):
        """
        Input: tick_data = {'symbol': price, ...}
        Output: dict of actions {'symbol': 'BUY'/'SELL'/'HOLD', ...}
        """
        actions = {}
        
        # 1. Update History & Manage Positions
        for symbol, price in tick_data.items():
            if symbol not in self.history:
                self.history[symbol] = deque(maxlen=self.max_history)
            self.history[symbol].append(price)
            
            # Check Exits (Stop Loss / Trailing Stop)
            if symbol in self.positions:
                pos = self.positions[symbol]
                
                # Update highest price seen for trailing stop
                if price > pos['highest_price']:
                    pos['highest_price'] = price
                    # Ratchet Stop: Move SL up if price moves up significantly (Secure 50% of peak gain)
                    new_sl = price - (price * 0.02) # Tight 2% trail
                    if new_sl > pos['stop_loss']:
                        pos['stop_loss'] = new_sl
                
                # Hard Stop Execution
                if price <= pos['stop_loss']:
                    actions[symbol] = 'SELL'
                    # Update local balance estimation
                    pnl = (price - pos['entry_price']) * pos['size']
                    self.balance += (pos['entry_price'] * pos['size']) + pnl
                    del self.positions[symbol]
                    continue

        # 2. Scan for Entries
        if len(self.positions) >= self.max_positions:
            return actions # Full house, manage existing only

        for symbol, price in tick_data.items():
            if symbol in self.positions or symbol in actions:
                continue
                
            history = self.history[symbol]
            if len(history) < self.max_history:
                continue
                
            # Indicators
            rsi = self.calculate_rsi(list(history), self.rsi_period)
            upper_bb, sma, lower_bb = self.get_bollinger_bands(history, self.bb_period, self.bb_std_dev)
            atr = self.get_atr(history)
            
            if not upper_bb or atr == 0:
                continue

            # Volatility Context
            volatility_ratio = atr / price
            is_high_volatility = volatility_ratio > 0.015 # 1.5% movement avg
            
            # Winner DNA: Price Action Confirmation
            tick_up = price > history[-2]
            
            # Strategy Logic
            signal = False
            
            # Regime A: Low Volatility -> Mean Reversion (Buy the dip)
            if not is_high_volatility:
                # RSI < 30 AND Price near Lower Band AND Tick Up
                if rsi < 30 and price <= (lower_bb * 1.01) and tick_up:
                    signal = True
            
            # Regime B: High Volatility -> Momentum Breakout (Ride the wave)
            else:
                # Price breaks SMA strongly AND RSI not overbought yet
                if price > sma and price > history[-2] and rsi > 50 and rsi < 70:
                    signal = True
            
            # Execution
            if signal:
                # Dynamic Sizing based on ATR (Volatility Sizing)
                # Risk amount = Balance * 0.02
                # Stop Distance = 2 * ATR
                # Size = Risk Amount / Stop Distance
                risk_amt = self.balance * self.risk_per_trade
                stop_distance = 2 * atr
                if stop_distance == 0: continue
                
                size = risk_amt / stop_distance
                
                # Cap size to max 20% of balance to avoid concentration
                max_cost = self.balance * 0.20
                if (size * price) > max_cost:
                    size = max_cost / price
                
                if (size * price) < self.balance:
                    self.positions[symbol] = {
                        'entry_price': price,
                        'size': size,
                        'stop_loss': price - stop_distance,
                        'highest_price': price
                    }
                    self.balance -= (size * price)
                    actions[symbol] = 'BUY'
                    
        return actions