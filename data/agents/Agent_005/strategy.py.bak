import random
import statistics
import math
from collections import deque

class MyStrategy:
    """
    Agent_005 Gen 52: 'Phoenix Rebound + Trailing Guard'
    
    [Evolution Logic]
    1.  **Winner DNA Integration (Agent_008)**: 
        -   Adopting RSI (14) < 30 as a hard filter to prevent catching falling knives.
        -   Requiring 'Tick Up' (Price > Prev Price) to confirm local support before entry.
    2.  **Legacy Trait Retention (Agent_005)**: 
        -   Retaining 'Time Decay' but relaxing it. If a trade stagnates, we exit, but we give it more room if volatility is high.
    3.  **New Mutation**: 
        -   **Trailing Profit Lock**: Instead of a fixed take-profit at the Mean, we track the 'High Water Mark' of the position. If price drops 1.5% from the peak of the trade, we exit to secure profits.
        -   **Volatility Sizing**: Position size is inversely proportional to Bollinger Bandwidth.
    """

    def __init__(self):
        print("ðŸ§  Strategy Initialized (Agent_005 Gen 52: Phoenix Rebound)")
        
        # --- Configuration ---
        self.lookback_window = 30       # Sufficient for RSI(14) and BB(20)
        self.rsi_period = 14
        self.bb_period = 20
        self.bb_std_dev = 2.0
        
        # --- State Management ---
        self.price_history = {}         # {symbol: deque(maxlen=30)}
        self.position_metadata = {}     # {symbol: {'entry_price': float, 'high_water_mark': float, 'ticks_held': int}}
        self.roi_history = deque(maxlen=10) # Track recent performance for adaptive sizing

    def calculate_rsi(self, prices, period=14):
        """Calculates RSI using Simple Moving Average method for speed/stability."""
        if len(prices) < period + 1:
            return 50.0 # Neutral default
        
        gains = []
        losses = []
        
        # Calculate changes
        for i in range(1, period + 1):
            change = prices[-i] - prices[-(i+1)]
            if change > 0:
                gains.append(change)
            else:
                losses.append(abs(change))
        
        avg_gain = sum(gains) / period
        avg_loss = sum(losses) / period
        
        if avg_loss == 0:
            return 100.0
        
        rs = avg_gain / avg_loss
        return 100.0 - (100.0 / (1.0 + rs))

    def next(self, context):
        """
        Main execution loop.
        context = {
            'data': {symbol: price, ...},
            'account': {'balance': float, 'equity': float},
            'positions': {symbol: size, ...}
        }
        """
        current_prices = context['data']
        account_balance = context['account']['balance']
        current_positions = context['positions']
        
        # 1. Update Data History
        for symbol, price in current_prices.items():
            if symbol not in self.price_history:
                self.price_history[symbol] = deque(maxlen=self.lookback_window)
            self.price_history[symbol].append(price)

        # 2. Manage Existing Positions (Exit Logic)
        for symbol, size in list(current_positions.items()):
            if size <= 0: continue # Skip shorts or empty
            
            current_price = current_prices[symbol]
            meta = self.position_metadata.get(symbol)
            
            # Initialize meta if missing (shouldn't happen usually)
            if not meta:
                meta = {'entry_price': current_price, 'high_water_mark': current_price, 'ticks_held': 0}
                self.position_metadata[symbol] = meta
            
            # Update State
            meta['ticks_held'] += 1
            if current_price > meta['high_water_mark']:
                meta['high_water_mark'] = current_price
            
            # --- Exit Conditions ---
            
            # A. Trailing Stop (Mutation): Lock in profits if price drops 1.5% from peak
            drawdown_from_peak = (meta['high_water_mark'] - current_price) / meta['high_water_mark']
            profit_pct = (current_price - meta['entry_price']) / meta['entry_price']
            
            should_sell = False
            exit_reason = ""

            # B. Hard Stop Loss (Risk Management) - 4% max loss
            if profit_pct < -0.04:
                should_sell = True
                exit_reason = "STOP_LOSS"
            
            # C. Trailing Stop (Dynamic)
            elif profit_pct > 0.01 and drawdown_from_peak > 0.008: # If we are in profit > 1%, tighten trail to 0.8%
                should_sell = True
                exit_reason = "TRAILING_PROFIT"
            elif drawdown_from_peak > 0.02: # Standard trailing stop 2%
                should_sell = True
                exit_reason = "TRAILING_GUARD"

            # D. RSI Overbought (Winner DNA)
            history = self.price_history[symbol]
            if len(history) >= self.lookback_window:
                rsi = self.calculate_rsi(list(history), self.rsi_period)
                if rsi > 75:
                    should_sell = True
                    exit_reason = "RSI_PEAK"
            
            # E. Time Decay (Legacy): Exit stagnation
            if meta['ticks_held'] > 15 and profit_pct < 0.005:
                should_sell = True
                exit_reason = "TIME_DECAY"

            if should_sell:
                print(f"ðŸ“‰ SELL {symbol}: {exit_reason} (PnL: {profit_pct*100:.2f}%)")
                del self.position_metadata[symbol]
                return [{'symbol': symbol, 'action': 'SELL', 'quantity': size}]

        # 3. Scan for New Entries (Entry Logic)
        orders = []
        # Allow max 4 positions to diversify risk
        if len(current_positions) >= 4:
            return orders

        # Sort symbols by volatility (prefer active assets) to avoid zombie coins
        candidates = []
        for symbol, history in self.price_history.items():
            if len(history) < self.lookback_window:
                continue
                
            prices = list(history)
            current_price = prices[-1]
            prev_price = prices[-2]
            
            # Calculate Indicators
            sma = statistics.mean(prices[-self.bb_period:])
            stdev = statistics.stdev(prices[-self.bb_period:])
            lower_band = sma - (self.bb_std_dev * stdev)
            bandwidth = (4 * stdev) / sma # Measure of volatility
            
            rsi = self.calculate_rsi(prices, self.rsi_period)
            
            # --- Entry Criteria (Confluence) ---
            
            # 1. Statistical Oversold (Winner DNA)
            is_dip = current_price < lower_band
            
            # 2. Momentum Oversold (Winner DNA)
            is_rsi_low = rsi < 32  # Slightly looser than 30 to get more hits
            
            # 3. Price Action Confirmation (Winner DNA)
            # We want to catch the bounce, not the knife. Price must be ticking UP.
            is_rebound = current_price > prev_price
            
            if is_dip and is_rsi_low and is_rebound:
                candidates.append((symbol, bandwidth))

        # Select best candidate
        if candidates:
            # Sort by bandwidth descending (higher vol = better mean reversion potential usually)
            candidates.sort(key=lambda x: x[1], reverse=True)
            target_symbol, vol = candidates[0]
            
            # Position Sizing: Inverse to volatility (High Vol = Smaller Size)
            # Base size $150, scaled down if volatility is extreme
            risk_scalar = 1.0
            if vol > 0.05: risk_scalar = 0.6
            if vol > 0.10: risk_scalar = 0.4
            
            amt_to_spend = min(account_balance, 180.0 * risk_scalar)
            
            if amt_to_spend > 20: # Minimum trade size
                quantity = amt_to_spend / current_prices[target_symbol]
                
                # Init metadata
                self.position_metadata[target_symbol] = {
                    'entry_price': current_prices[target_symbol],
                    'high_water_mark': current_prices[target_symbol],
                    'ticks_held': 0
                }
                
                print(f"ðŸš€ BUY {target_symbol}: RSI Oversold + BB Dip + Rebound (Vol: {vol:.3f})")
                orders.append({'symbol': target_symbol, 'action': 'BUY', 'quantity': quantity})

        return orders