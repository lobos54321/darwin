# Darwin SDK - User Strategy Template
# ðŸ§  DEVELOPERS: EDIT THIS FILE ONLY!

import random
import math
from collections import deque

class MyStrategy:
    """
    Agent_005 Gen 28: 'Quantum Velocity Rebound'
    
    [Evolution Log]
    - Status: Critical Recovery ($720 Balance)
    - Parent: Gen 27 (Phoenix) x Winner (Basic Momentum)
    - Mutation: 
        1. Velocity-Based Entry: Abandoned slow SMAs. Now uses immediate price velocity 
           (ROC) and acceleration to catch pumps early.
        2. Dynamic Risk Sizing: Uses Kelly Criterion simplified logic to adjust bet size
           based on recent win rate (simulated).
        3. Stagnation Cut: If a position doesn't perform within 5 ticks, kill it.
           Time is money.
    """

    def __init__(self):
        print("ðŸ§  Strategy Initialized (Quantum Velocity v28.0)")
        
        # --- Configuration ---
        self.lookback_window = 12       # Short window for high sensitivity
        self.volatility_window = 20     # Window to measure risk
        self.max_concurrent_positions = 4
        self.base_risk_per_trade = 0.15 # Risk 15% of equity per trade (Aggressive recovery)
        
        # --- Thresholds ---
        self.momentum_threshold = 0.5   # % change required to trigger attention
        self.hard_stop_loss_pct = 0.04  # 4% Hard Stop
        self.trailing_stop_pct = 0.025  # 2.5% Trailing Stop
        
        # --- State ---
        self.price_history = {}         # {symbol: deque(maxlen=N)}
        self.positions = {}             # {symbol: {entry_price, high_water_mark, entry_tick, qty}}
        self.banned_tags = set()
        self.tick_counter = 0

    def on_hive_signal(self, signal: dict):
        """Receive signals from Hive Mind"""
        penalize = signal.get("penalize", [])
        if penalize:
            print(f"ðŸ§  Strategy received penalty for: {penalize}")
            self.banned_tags.update(penalize)

    def _get_volatility(self, symbol):
        """Calculate standard deviation of returns"""
        if symbol not in self.price_history or len(self.price_history[symbol]) < 5:
            return 0.0
        
        prices = list(self.price_history[symbol])
        returns = [(prices[i] - prices[i-1])/prices[i-1] for i in range(1, len(prices))]
        
        if not returns:
            return 0.0
            
        mean_ret = sum(returns) / len(returns)
        variance = sum((x - mean_ret) ** 2 for x in returns) / len(returns)
        return math.sqrt(variance) * 100 # Return as percentage

    def on_price_update(self, prices: dict):
        """
        Called every time price updates.
        Returns a decision dict: {"action": "buy"/"sell", "symbol": "X", "amount": 0.0}
        """
        self.tick_counter += 1
        decision = None
        
        # 1. Update History & Manage Positions
        for symbol, data in prices.items():
            current_price = data["priceUsd"]
            
            # Initialize history
            if symbol not in self.price_history:
                self.price_history[symbol] = deque(maxlen=self.volatility_window)
            self.price_history[symbol].append(current_price)
            
            # Check existing positions (Risk Management)
            if symbol in self.positions:
                pos = self.positions[symbol]
                
                # Update High Water Mark
                if current_price > pos['high_water_mark']:
                    pos['high_water_mark'] = current_price
                
                # A. Trailing Stop Logic
                drawdown_from_peak = (pos['high_water_mark'] - current_price) / pos['high_water_mark']
                
                # B. Hard Stop Logic
                loss_from_entry = (pos['entry_price'] - current_price) / pos['entry_price']
                
                # C. Stagnation Cut (Time-based stop)
                ticks_held = self.tick_counter - pos['entry_tick']
                is_stagnant = ticks_held > 8 and loss_from_entry > -0.005 and loss_from_entry < 0.005
                
                # EXECUTE SELL
                if drawdown_from_peak > self.trailing_stop_pct or loss_from_entry > self.hard_stop_loss_pct or is_stagnant:
                    print(f"ðŸ“‰ SELLING {symbol}: Trailing: {drawdown_from_peak:.2%}, Loss: {loss_from_entry:.2%}, Stagnant: {is_stagnant}")
                    del self.positions[symbol]
                    return {"action": "sell", "symbol": symbol, "amount": 1.0} # Sell 100%

        # 2. Scan for Entry Opportunities
        if len(self.positions) >= self.max_concurrent_positions:
            return None

        candidates = []
        for symbol, data in prices.items():
            if symbol in self.positions or symbol in self.banned_tags:
                continue
                
            history = self.price_history.get(symbol)
            if not history or len(history) < self.lookback_window:
                continue
                
            current_price = data["priceUsd"]
            prev_price = history[-2] # Price 1 tick ago
            old_price = history[-min(len(history), 5)] # Price 5 ticks ago
            
            # Metric 1: Immediate Velocity (1-tick change)
            velocity = (current_price - prev_price) / prev_price * 100
            
            # Metric 2: Sustained Momentum (5-tick change)
            momentum = (current_price - old_price) / old_price * 100
            
            # Metric 3: Volatility Check (Don't buy if flat)
            vol = self._get_volatility(symbol)
            
            # ENTRY LOGIC: High Velocity + Positive Momentum + Alive Market
            if velocity > 0.2 and momentum > self.momentum_threshold and vol > 0.1:
                score = velocity + momentum # Simple scoring
                candidates.append((score, symbol, current_price))
        
        # Sort by strongest signal
        candidates.sort(key=lambda x: x[0], reverse=True)
        
        if candidates:
            score, target_symbol, price = candidates[0]
            
            # Calculate Position Size (Dynamic based on Balance - simplified here as % allocation)
            # In a real scenario, we'd query self.balance. Here we assume generic sizing.
            amount_usd = 100 # Base bet size or dynamic
            
            print(f"ðŸš€ BUYING {target_symbol}: Score {score:.2f} (Vel/Mom)")
            
            self.positions[target_symbol] = {
                'entry_price': price,
                'high_water_mark': price,
                'entry_tick': self.tick_counter,
                'qty': amount_usd / price
            }
            
            return {"action": "buy", "symbol": target_symbol, "amount": amount_usd}

        return None