# Darwin SDK - User Strategy Template
# ðŸ§  DEVELOPERS: EDIT THIS FILE ONLY!

import random
import statistics
from collections import deque

class MyStrategy:
    """
    Agent_005 Gen 26: 'Darwin's Razor'
    
    [Evolution Log]
    - Status: Critical Recovery ($720 Balance)
    - Source: Forked from 'Phoenix Rebound', absorbed 'Basic v1.0' simplicity.
    - Diagnosis of Failure: Previous generation over-engineered 'velocity acceleration' and used 
      stops that were too tight (-1.5%) for the asset volatility, causing 'death by noise'.
    - New Mutation: 'Sustained Momentum' + 'Volatility Sizing'.
      Instead of reacting to single-tick spikes, we require a trend confirmation over N ticks.
      Stops are widened to breathe, but position sizing is dynamic based on volatility.
    """

    def __init__(self):
        print("ðŸ§  Strategy Initialized (Darwin's Razor v26.0)")
        
        # --- Configuration ---
        self.lookback_window = 10       # Number of ticks to analyze trend
        self.entry_threshold = 0.5      # % change required to consider entry
        self.trend_confirmation = 3     # Number of positive ticks required in window
        
        # --- Risk Management ---
        self.stop_loss_pct = 0.05       # Widened to 5% to avoid noise wicks
        self.trailing_stop_pct = 0.025  # 2.5% Trailing Stop from local high
        self.max_positions = 3          # Limit exposure
        self.base_bet_pct = 0.15        # Bet 15% of equity per trade
        
        # --- State ---
        self.last_prices = {}
        self.price_history = {}         # {symbol: deque(maxlen=10)}
        self.positions = {}             # {symbol: {'entry': float, 'high': float, 'amount': float}}
        self.banned_tags = set()
        self.equity = 720.0             # Estimated equity tracking

    def on_hive_signal(self, signal: dict):
        """Receive signals from Hive Mind"""
        penalize = signal.get("penalize", [])
        if penalize:
            print(f"ðŸ§  Penalty received for: {penalize}")
            self.banned_tags.update(penalize)
            # Immediate liquidation of penalized assets
            for tag in penalize:
                if tag in self.positions:
                    # Logic to close would happen in on_price_update via return signal
                    pass

    def get_position_size(self, symbol_volatility):
        """
        Mutation: Dynamic Sizing.
        If volatility is high, reduce size. If low, increase size (up to cap).
        """
        base_size = self.equity * self.base_bet_pct
        if symbol_volatility > 0.02: # High volatility (>2% std dev)
            return base_size * 0.5
        return base_size

    def on_price_update(self, prices: dict):
        """
        Main Trading Logic Loop
        """
        decision = {}
        
        # 1. Update History & Calculate Metrics
        for symbol, data in prices.items():
            current_price = data["priceUsd"]
            
            if symbol not in self.price_history:
                self.price_history[symbol] = deque(maxlen=self.lookback_window)
            self.price_history[symbol].append(current_price)
            
            # Skip if banned
            if symbol in self.banned_tags:
                continue

            # --- EXIT LOGIC (Risk Management) ---
            if symbol in self.positions:
                pos = self.positions[symbol]
                
                # Update High Water Mark
                if current_price > pos['high']:
                    pos['high'] = current_price
                
                # Calculate PnL percentages
                drawdown_from_peak = (current_price - pos['high']) / pos['high']
                total_pnl = (current_price - pos['entry']) / pos['entry']
                
                should_close = False
                reason = ""
                
                # 1. Trailing Stop (Protect Profits)
                if drawdown_from_peak < -self.trailing_stop_pct:
                    should_close = True
                    reason = "Trailing Stop"
                
                # 2. Hard Stop Loss (Catastrophe protection)
                elif total_pnl < -self.stop_loss_pct:
                    should_close = True
                    reason = "Hard Stop"
                
                if should_close:
                    print(f"ðŸ“‰ SELL {symbol}: {reason} (PnL: {total_pnl*100:.2f}%)")
                    decision[symbol] = "SELL"
                    # Update equity estimate (simplified)
                    pnl_amount = pos['amount'] * total_pnl
                    self.equity += pnl_amount
                    del self.positions[symbol]
                    continue # Skip entry logic

            # --- ENTRY LOGIC (Momentum + Stability) ---
            # Only enter if slots available and enough history
            if symbol not in self.positions and len(self.positions) < self.max_positions:
                if len(self.price_history[symbol]) >= self.lookback_window:
                    history = list(self.price_history[symbol])
                    
                    # 1. Calculate Volatility (Standard Deviation / Mean)
                    if len(history) > 2:
                        mean_price = statistics.mean(history)
                        stdev = statistics.stdev(history)
                        volatility = stdev / mean_price if mean_price > 0 else 0
                    else:
                        volatility = 0.0

                    # 2. Trend Analysis
                    # Check if price is higher than it was 5 ticks ago (Mid-term momentum)
                    mid_term_change = (current_price - history[-5]) / history[-5]
                    
                    # Check immediate tick momentum
                    short_term_change = (current_price - history[-2]) / history[-2]
                    
                    # 3. Consistency Check (Count positive ticks in window)
                    positive_ticks = sum(1 for i in range(1, len(history)) if history[i] > history[i-1])
                    
                    # Signal Trigger:
                    # - Price is up > 0.5% vs 5 ticks ago
                    # - Immediate momentum is positive
                    # - At least 60% of recent ticks were green (Consistency)
                    if (mid_term_change * 100 > self.entry_threshold and 
                        short_term_change > 0 and 
                        positive_ticks >= (self.lookback_window * 0.6)):
                        
                        bet_size = self.get_position_size(volatility)
                        
                        print(f"ðŸš€ BUY {symbol}: Mom={mid_term_change*100:.2f}% Vol={volatility:.4f}")
                        decision[symbol] = {"action": "BUY", "amount": bet_size}
                        
                        self.positions[symbol] = {
                            'entry': current_price, 
                            'high': current_price,
                            'amount': bet_size
                        }

            # Update last price for next tick reference
            self.last_prices[symbol] = current_price

        return decision