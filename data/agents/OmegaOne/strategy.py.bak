```python
# Darwin SDK - User Strategy Template
# ğŸ§  DEVELOPERS: EDIT THIS FILE ONLY!

import random
import math
from collections import deque, defaultdict

class MyStrategy:
    def __init__(self):
        print("ğŸ§  Strategy Evolved: OmegaOne V2 (Mean Reversion + Dynamic Risk)")
        
        # --- è¿›åŒ–é…ç½® (Evolution Config) ---
        self.lookback_period = 12      # SMA Period
        self.stop_loss_pct = 0.04      # 4% Hard Stop
        self.take_profit_pct = 0.12    # 12% Target Profit
        self.trailing_stop_pct = 0.025 # 2.5% Trailing Stop
        self.max_pos_usd = 50.0        # Max size per trade
        
        # --- çŠ¶æ€è¿½è¸ª (State Tracking) ---
        self.last_prices = {}
        self.price_history = defaultdict(lambda: deque(maxlen=20))
        # Portfolio: {symbol: {'entry': float, 'high': float, 'amt': float}}
        self.portfolio = {} 
        self.banned_tags = set()
        self.boosted_tags = set()
        
        # å†…éƒ¨ç°é‡‘ä¼°ç®— (ç”¨äºä»“ä½ç®¡ç†)
        self.estimated_cash = 639.51 

    def on_hive_signal(self, signal: dict):
        """Receive signals from Hive Mind"""
        penalize = signal.get("penalize", [])
        if penalize:
            print(f"ğŸ›¡ï¸ Risk Control: Banning {penalize}")
            self.banned_tags.update(penalize)
            
        boost = signal.get("boost", [])
        if boost:
            # è¿›åŒ–ç‚¹ï¼šæ”¶åˆ° Boost ä¿¡å·æ—¶æ¸…ç©ºè¯¥å¸ç§çš„å†å²é»‘åå•
            self.boosted_tags.update(boost)
            self.banned_tags.difference_update(boost)

    def _get_indicators(self, symbol):
        """Calculate SMA and Volatility"""
        history = list(self.price_history[symbol])
        if len(history) < self.lookback_period:
            return None, None
            
        # SMA
        sma = sum(history[-self.lookback_period:]) / self.lookback_period
        
        # Volatility (Std Dev)
        variance = sum([((x - sma) ** 2) for x in history[-self.lookback_period:]]) / self.lookback_period
        std_dev = math.sqrt(variance)
        
        return sma, std_dev

    def on_price_update(self, prices: dict):
        """
        Called every time price updates.
        Returns: ("BUY"/"SELL", symbol, amount_usd) or None
        """
        decision = None
        
        for symbol, data in prices.items():
            current_price = data["priceUsd"]
            
            # Update Data
            self.price_history[symbol].append(current_price)
            self.last_prices[symbol] = current_price
            
            # --- 1. é£æ§æ¨¡å— (Risk Management) ---
            if symbol in self.portfolio:
                pos = self.portfolio[symbol]
                entry = pos['entry']
                
                # æ›´æ–°æœ€é«˜ä»· (High Water Mark)
                if current_price > pos['high']:
                    pos['high'] = current_price
                
                # è®¡ç®—ç›ˆäºæŒ‡æ ‡
                pnl_pct = (current_price - entry) / entry
                drawdown = (pos['high'] - current_price) / pos['high']
                
                # æ­¢æŸ/æ­¢ç›ˆé€»è¾‘
                action = None
                if pnl_pct <= -self.stop_loss_pct:
                    print(f"ğŸ›‘ STOP LOSS: {symbol} @ {pnl_pct*100:.2f}%")
                    action = "SELL"
                elif pnl_pct >= self.take_profit_pct:
                    print(f"ğŸ’° TAKE PROFIT: {symbol} @ {pnl_pct*100:.2f}%")
                    action = "SELL"
                elif pnl_pct > 0.03 and drawdown >= self.trailing_stop_pct:
                    print(f"ğŸ“‰ TRAILING STOP: {symbol} locked gains")
                    action = "