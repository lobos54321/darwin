```python
import math
import statistics
import random
from collections import deque, defaultdict

class MyStrategy:
    """
    Agent: Copy_Trader_952 (Gen 7 - Phoenix Rebirth)
    
    Evolutionary Improvements:
    1.  [Inherited from Winner] RSI Confluence: Replaced Z-Score breakouts with RSI Mean Reversion to stop catching 'falling knives'.
    2.  [Inherited from Winner] Price Action: Added 'Tick Up' & Green Candle confirmation before entry.
    3.  [Mutation - Volatility Filter] ATR-Based Dynamic Sizing: Position size scales inversely with volatility.
    4.  [Mutation - Survival Mode] Capital Preservation: If Balance < $600, activates 'Sniper Protocol' (only takes A+ setups with RSI < 25).
    5.  [Risk] Dynamic Stop Loss: Uses 2.5x ATR for stops instead of fixed %, allowing breathing room for volatile assets.
    """

    def __init__(self):
        print("ðŸ§  Strategy Initialized (Gen 7: Phoenix Rebirth - RSI/ATR Hybrid)")
        
        # === Configuration ===
        self.rsi_period = 14
        self.atr_period = 14
        self.ma_period = 50
        
        # === Risk Management ===
        self.base_risk_per_trade = 0.02  # Risk 2% of equity per trade
        self.max_positions = 4           # Diversification
        self.min_roi_target = 0.04       # Target 4% gain
        
        # === Data Storage ===
        self.history = defaultdict(lambda: {
            'close': deque(maxlen=100),
            'high': deque(maxlen=100),
            'low': deque(maxlen=100),
            'volume': deque(maxlen=100)
        })
        
        self.positions = {} # {symbol: {'entry': float, 'stop': float, 'size': float}}
        self.blacklisted = set()

    def calculate_rsi(self, prices):
        if len(prices) < self.rsi_period + 1:
            return 50.0
            
        deltas = [prices[i] - prices[i-1] for i in range(1, len(prices))]
        gains = [d if d > 0 else 0 for d in deltas]
        losses = [abs(d) if d < 0 else 0 for d in deltas]
        
        avg_gain = sum(gains[-self.rsi_period:]) / self.rsi_period
        avg_loss = sum(losses[-self.rsi_period:]) / self.rsi_period
        
        if avg_loss == 0:
            return 100.0
            
        rs = avg_gain / avg_loss
        return 100.0 - (100.0 / (1.0 + rs))

    def calculate_atr(self, symbol):
        highs = self.history[symbol]['high']
        lows = self.history[symbol]['low']
        closes = self.history[symbol]['close']
        
        if len(closes) < self.atr_period + 1:
            return 0.0
            
        tr_list = []
        for i in range(1, len(closes)):
            hl = highs[i] - lows[i]
            hc = abs(highs[i] - closes[i-1])
            lc = abs(lows[i] - closes[i-1])
            tr_list.append(max(hl, hc, lc))
            
        return sum(tr_list[-self.atr_period:]) / self.atr_period

    def get_position_size(self, current_balance, atr, price):
        # Volatility Sizing: Higher ATR = Smaller Position
        # Risk amount = current_balance * self.base_risk_per_trade
        # Stop distance = 2.5 * ATR
        # Shares = Risk amount / Stop distance
        
        if atr == 0: return 0
        
        risk_amt = current_balance * self.base_risk_per_trade
        stop_distance = 2.5 * atr
        
        # Safety clamp: Don't bet more than 15% of account on one trade
        max_usd_allocation = current_balance * 0.15
        
        position_value = (risk_amt / stop_distance) * price
        return min(position_value, max_usd_allocation)

    def next(self, market_data, account_balance):
        """
        Main execution loop.
        market_data: list of dicts [{'symbol': 'BTC', 'close': 50000, 'high':..., 'low':..., 'vol':...}]
        account_balance: float
        """
        orders = []
        
        # Survival Mode Check
        is_survival_mode = account_balance < 600
        rsi_buy_threshold = 25 if is_survival_mode else 30
        
        for asset in market_data:
            sym = asset['symbol']
            close = asset['close']
            high = asset['high']
            low = asset['low']
            vol = asset['volume']
            
            # Update History
            self.history[sym]['close'].append(close)
            self.history[sym]['high'].append(high)
            self.history[sym]['low'].append(low)
            self.history[sym]['volume'].append(vol)
            
            if len(self.history[sym]['close']) < self.ma_period:
                continue

            # --- Manage Existing Positions ---
            if sym in self.positions:
                pos = self.positions[sym]
                pnl_pct = (close - pos['entry']) / pos['entry']
                
                # Dynamic Exit Logic
                # 1. Hard Stop (ATR based)
                if close < pos['stop']:
                    orders.append({'symbol': sym, 'action': 'SELL', 'reason': 'STOP_LOSS'})
                    del self.positions[sym]
                    continue
                    
                # 2. Take Profit (RSI Overbought)
                current_rsi = self.calculate_rsi(self.history[sym]['close'])
                if current_rsi > 70 or pnl_pct > self.min_roi_target:
                    # Trailing Stop Logic: If profitable, tighten stop instead of selling immediately?
                    # For now, secure the bag to fix the -46% PnL.
                    orders.append({'symbol': sym, 'action': 'SELL', 'reason': 'TAKE_PROFIT'})
                    del self.positions[sym]
                    continue
                    
            # --- New Entry Logic ---
            elif len(self.positions) < self.max_positions and sym not in self.blacklisted:
                
                # Calculate Indicators
                rsi = self.calculate_rsi(self.history[sym]['close'])
                atr = self.calculate