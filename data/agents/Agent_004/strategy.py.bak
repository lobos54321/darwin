import math
import statistics
from collections import deque
from typing import Dict, Optional

class MyStrategy:
    """
    Agent_004 Gen 9: "Apex Predator" (Trend Breakout + Volatility Trailing)
    
    Evolution Log:
    1.  **Pivot from Mean Reversion**: The previous "Pullback" strategy failed (caught falling knives). 
        Gen 9 shifts to "Trend Following" (Bollinger Breakout) to align with market momentum.
    2.  **Survival Risk Management**: 
        - Hard Stop Loss fixed at 2.5% (tighter due to drawdown).
        - Trailing Profit Activation at +1.5% to secure small wins and rebuild equity.
    3.  **Volatility Filter**: Only trade when bandwidth expands (avoid chop).
    """

    def __init__(self):
        print("ðŸ§  Strategy Initialized (Agent_004 Gen 9: Apex Predator)")
        
        # Configuration
        self.lookback_period = 20
        self.std_dev_multiplier = 2.0
        self.risk_per_trade = 0.10  # Invest 10% of balance per trade
        self.stop_loss_pct = 0.025  # 2.5% Hard Stop
        self.trailing_start_pct = 0.015 # Start trailing after 1.5% gain
        self.trailing_step_pct = 0.01   # Trail distance
        
        # State
        self.price_history: Dict[str, deque] = {} # Symbol -> deque of prices
        self.positions: Dict[str, dict] = {}      # Symbol -> {entry_price, highest_price, amount}
        self.banned_tags = set()
        self.balance = 850.20 # Sync with actual engine balance

    def on_hive_signal(self, signal: dict):
        """Absorb Hive Mind signals but maintain autonomy."""
        penalize = signal.get("penalize", [])
        if penalize:
            self.banned_tags.update(penalize)

    def _get_indicators(self, symbol: str) -> Optional[dict]:
        """Calculate SMA and Bollinger Bands."""
        history = self.price_history.get(symbol)
        if not history or len(history) < self.lookback_period:
            return None
            
        prices = list(history)
        sma = statistics.mean(prices)
        stdev = statistics.stdev(prices)
        
        return {
            "sma": sma,
            "upper_band": sma + (stdev * self.std_dev_multiplier),
            "lower_band": sma - (stdev * self.std_dev_multiplier),
            "bandwidth": (stdev / sma) * 100 # Volatility %
        }

    def on_price_update(self, prices: dict):
        """
        Main Trading Logic Loop
        """
        decisions = []
        
        for symbol, data in prices.items():
            current_price = data["priceUsd"]
            
            # 1. Update History
            if symbol not in self.price_history:
                self.price_history[symbol] = deque(maxlen=self.lookback_period)
            self.price_history[symbol].append(current_price)
            
            # 2. Manage Existing Positions (Risk Management First)
            if symbol in self.positions:
                self._manage_position(symbol, current_price)
                continue # Don't buy if we already own
            
            # 3. Check for Entry Signals
            indicators = self._get_indicators(symbol)
            if not indicators:
                continue
                
            # Logic: Breakout Strategy
            # Buy if price breaks above Upper Bollinger Band AND volatility is expanding
            is_breakout = current_price > indicators["upper_band"]
            is_volatility_ok = indicators["bandwidth"] > 0.5 # Avoid dead markets
            
            if is_breakout and is_volatility_ok and symbol not in self.banned_tags:
                self._execute_buy(symbol, current_price)

    def _execute_buy(self, symbol: str, price: float):
        """Execute buy order with position sizing based on current depleted capital."""
        trade_amount = self.balance * self.risk_per_trade
        
        if trade_amount > 5: # Minimum trade size constraint
            print(f"ðŸš€ BUY {symbol} @ ${price:.4f} (Breakout)")
            self.positions[symbol] = {
                "entry_price": price,
                "highest_price": price,
                "amount_usd": trade_amount,
                "trailing_active": False
            }
            self.balance -= trade_amount

    def _manage_position(self, symbol: str, current_price: float):
        """Handle Stop Loss, Take Profit, and Trailing Stops."""
        pos = self.positions[symbol]
        entry_price = pos["entry_price"]
        
        # Update Highest Price for Trailing calculation
        if current_price > pos["highest_price"]:
            pos["highest_price"] = current_price
            
        # PnL Calculation
        pnl_pct = (current_price - entry_price) / entry_price
        
        # 1. Hard Stop Loss Check
        if pnl_pct < -self.stop_loss_pct:
            self._close_position(symbol, current_price, "ðŸ›‘ Stop Loss")
            return

        # 2. Trailing Stop Logic
        # Activate trailing if we crossed the profit threshold
        if pnl_pct >= self.trailing_start_pct:
            pos["trailing_active"] = True
            
        if pos["trailing_active"]:
            # Drop from highest point
            drawdown_from_peak = (pos["highest_price"] - current_price) / pos["highest_price"]
            if drawdown_from_peak >= self.trailing_step_pct:
                self._close_position(symbol, current_price, "ðŸ’° Trailing Profit")
                return

        # 3. Trend Reversal Exit (Standard Deviation Reversion)
        # If price falls back below SMA, momentum is lost.
        indicators = self._get_indicators(symbol)
        if indicators and current_price < indicators["sma"]:
             # Only exit if we are at least break-even or small loss to avoid chop, 
             # otherwise wait for Hard Stop
            if pnl_pct > -0.01: 
                self._close_position(symbol, current_price, "ðŸ“‰ Trend Reversal")

    def _close_position(self, symbol: str, price: float, reason: str):
        """Close trade and update balance."""
        pos = self.positions.pop(symbol)
        pnl = (price - pos["entry_price"]) / pos["entry_price"]
        return_amount = pos["amount_usd"] * (1 + pnl)
        
        self.balance += return_amount
        print(f"{reason} {symbol} @ ${price:.4f} | PnL: {pnl*100:.2f}% | Bal: ${self.balance:.2f}")