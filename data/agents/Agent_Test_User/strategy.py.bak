# Darwin SDK - User Strategy Template
# ğŸ§  DEVELOPERS: EDIT THIS FILE ONLY!

import random
from collections import deque

class MyStrategy:
    def __init__(self):
        print("ğŸ§  Strategy Evolved: MomentumAlpha_v2 (Risk-Adjusted)")
        
        # æ ¸å¿ƒå‚æ•° (Evolution Parameters)
        self.history_window = 20    # ä»·æ ¼å†å²çª—å£
        self.ma_short_period = 5    # çŸ­æœŸå‡çº¿
        self.ma_long_period = 15    # é•¿æœŸå‡çº¿
        self.stop_loss_pct = 0.05   # 5% æ­¢æŸ
        self.take_profit_pct = 0.15 # 15% æ­¢ç›ˆ
        self.trailing_stop_pct = 0.03 # 3% ç§»åŠ¨æ­¢ç›ˆå›æ’¤
        
        # çŠ¶æ€è¿½è¸ª
        self.last_prices = {}
        self.price_history = {}     # {symbol: deque([prices], maxlen=20)}
        self.positions = {}         # {symbol: {'entry': float, 'high': float}}
        self.banned_tags = set()
        
        # å†·å´æœºåˆ¶ (é¿å…é¢‘ç¹äº¤æ˜“)
        self.cooldowns = {}         # {symbol: ticks_remaining}

    def on_hive_signal(self, signal: dict):
        """Receive signals from Hive Mind"""
        penalize = signal.get("penalize", [])
        if penalize:
            print(f"âš ï¸ Penalty received for: {penalize}")
            self.banned_tags.update(penalize)
            # ç«‹å³æ¸…ä»“è¢«æƒ©ç½šçš„ä»£å¸
            for tag in penalize:
                if tag in self.positions:
                    del self.positions[tag]
            
        boost = signal.get("boost", [])
        if boost:
            # å¯ä»¥åœ¨æ­¤å¤„é™ä½ Boost ä»£å¸çš„ä¹°å…¥é˜ˆå€¼
            pass

    def _update_history(self, symbol, price):
        if symbol not in self.price_history:
            self.price_history[symbol] = deque(maxlen=self.history_window)
        self.price_history[symbol].append(price)

    def _get_sma(self, symbol, period):
        history = self.price_history.get(symbol, [])
        if len(history) < period:
            return None
        return sum(list(history)[-period:]) / period

    def on_price_update(self, prices: dict):
        """
        Main Trading Loop
        """
        best_decision = None
        highest_score = -1
        
        for symbol, data in prices.items():
            current_price = data["priceUsd"]
            change_24h = data.get("priceChange24h", 0)
            
            # 1. æ›´æ–°æ•°æ®
            self._update_history(symbol, current_price)
            self.last_prices[symbol] = current_price
            
            # å†·å´å¤„ç†
            if self.cooldowns.get(symbol, 0) > 0:
                self.cooldowns[symbol] -= 1
                continue

            # 2. é£æ§æ£€æŸ¥ (Risk Management) - ä¼˜å…ˆå¤„ç†æŒä»“
            if symbol in self.positions:
                entry_price = self.positions[symbol]['entry']
                max_price = self.positions[symbol]['high']
                
                # æ›´æ–°æœ€é«˜ä»·ç”¨äºç§»åŠ¨æ­¢ç›ˆ
                if current_price > max_price:
                    self.positions[symbol]['high'] = current_price
                    max_price = current_price
                
                # A. æ­¢æŸæ£€æŸ¥ (Hard Stop Loss)
                if current_price < entry_price * (1 - self.stop_loss_pct):
                    print(f"ğŸ›‘ STOP LOSS triggered for {symbol}")
                    del self.positions[symbol]
                    self.cooldowns[symbol] = 10 # å†·å´
                    return {"action": "sell", "token": symbol, "amount": "100%"}
                
                # B. ç§»åŠ¨æ­¢ç›ˆæ£€æŸ¥ (Trailing Stop)
                if current_price < max_price * (1 - self.trailing_stop_pct) and current_price > entry_price * 1.02:
                    print(f"ğŸ’° TRAILING PROFIT triggered for {symbol}")
                    del self.positions[symbol]
                    self.cooldowns[symbol] = 5
                    return {"action": "sell", "token": symbol, "amount": "100%"}
                    
                continue # æŒä»“ä¸­è‹¥æœªè§¦å‘å–å‡ºï¼Œåˆ™è·³è¿‡ä¹°å…¥é€»è¾‘

            # 3. ç­–ç•¥é€»è¾‘ (Strategy Logic) - å¯»æ‰¾ä¹°å…¥æœºä¼š
            if symbol in self.banned_tags:
                continue
                
            sma_short = self._get_sma(symbol, self.ma_short_period)
            sma_long = self._get_sma(symbol, self.ma_long_period)
            
            if sma_short and sma_long:
                # å˜å¼‚é€»è¾‘ï¼šåŒå‡çº¿é‡‘å‰ + 24å°æ—¶è¶‹åŠ¿å‘ä¸Š + æ³¢åŠ¨ç‡è¿‡æ»¤
                # é¿å…åœ¨ä¸‹è·Œè¶‹åŠ¿ä¸­æ¥é£åˆ€
                is_uptrend = sma_short > sma_long
                is_strong_day = change_24h > 2.0 # 24hæ¶¨å¹…å¤§äº2%
                
                # è®¡ç®—åŠ¨é‡åˆ†
                momentum_score = (sma_short - sma_long) / sma_long
                
                if is_uptrend and is_strong_day and momentum_score > 0.005:
                    if momentum_score > highest_score:
                        highest_score = momentum_score
                        # è®°å½•è™šæ‹ŸæŒä»“
                        self.positions[symbol] = {'entry': current_price, 'high': current_price}
                        # åŠ¨æ€ä»“ä½ï¼šæ ¹æ®åŠ¨é‡å¼ºåº¦å†³å®šä¹°å…¥æ¯”ä¾‹ (10% - 30%)
                        allocation = min(0.3, 0.1 + (momentum_score * 10))
                        best_decision = {
                            "action": "buy", 
                            "token": symbol, 
                            "amount": f"{int(allocation * 100)}%"
                        }

        # 4. æ‰§è¡Œæœ€ä½³å†³ç­–
        return best_decision