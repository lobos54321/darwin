import math
import statistics
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
from collections import deque

# === åŸºç¡€æ•°æ®ç»“æ„å®šä¹‰ (ä¿æŒå…¼å®¹æ€§) ===

class Signal(Enum):
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"

@dataclass
class TradeDecision:
    signal: Signal
    symbol: str
    amount_usd: float
    reason: str

@dataclass
class Position:
    symbol: str
    entry_price: float
    amount_usd: float
    timestamp: int  # è¿™é‡Œçš„ timestamp æ¨¡æ‹Ÿ tick è®¡æ•°
    highest_price: float

# === è¿›åŒ–åçš„ç­–ç•¥æ ¸å¿ƒ ===

class DarwinStrategy:
    """
    Agent: Diamond_Hands_533 (Gen 3 - "Phoenix")
    
    è¿›åŒ–æ—¥å¿—:
    1. æŠ›å¼ƒæ»åçš„ EMA äº¤å‰ï¼Œæ”¹ç”¨ç¬æ—¶åŠ¨é‡ (Instant Momentum) å’Œæ³¢åŠ¨ç‡çªç ´ã€‚
    2. å¼•å…¥ "æ—¶é—´æ­¢æŸ (Time Stop)"ï¼šå¦‚æœæŒä»“ n ä¸ªå‘¨æœŸä¸ç›ˆåˆ©ï¼Œå¼ºåˆ¶å¹³ä»“ï¼Œæ‹’ç»æ­»æ‹¿ã€‚
    3. åŠ¨æ€ä»“ä½ï¼šåŸºäºæ³¢åŠ¨ç‡è°ƒæ•´ä»“ä½å¤§å°ï¼Œæ³¢åŠ¨è¶Šå¤§ä»“ä½è¶Šå°ã€‚
    4. å¬ä» Hive Mindï¼šä¸¥æ ¼æ‰§è¡Œæƒ©ç½šä¿¡å· (banned_tags)ã€‚
    """

    def __init__(self):
        print("ğŸ§  Strategy Initialized: Phoenix v3.0 (Evolutionary)")
        
        # === æ ¸å¿ƒå‚æ•° ===
        self.lookback_window = 20      # ä»·æ ¼å›æº¯çª—å£
        self.momentum_threshold = 0.008 # 0.8% ç¬æ—¶çªç ´é˜ˆå€¼
        self.stop_loss_pct = 0.025     # 2.5% ç¡¬æ­¢æŸ
        self.take_profit_pct = 0.06    # 6% æ­¢ç›ˆ
        self.trailing_arm = 0.015      # 1.5% æ¿€æ´»ç§»åŠ¨æ­¢æŸ
        self.max_hold_ticks = 15       # æ—¶é—´æ­¢æŸï¼š15ä¸ªtickä¸æ¶¨å°±è·‘
        
        # === èµ„é‡‘ç®¡ç† ===
        self.balance = 536.69          # å½“å‰ä½™é¢
        self.base_bet_size = 0.20      # åŸºç¡€ä»“ä½ 20%
        
        # === å†…éƒ¨çŠ¶æ€ ===
        self.tick_counter = 0
        self.price_history: Dict[str, deque] = {}
        self.positions: Dict[str, Position] = {}
        self.banned_tags: set = set()
        self.volatility_map: Dict[str, float] = {}

    def on_hive_signal(self, signal: dict):
        """å¤„ç† Hive Mind ä¿¡å· (å¸æ”¶èµ¢å®¶æ™ºæ…§)"""
        penalize = signal.get("penalize", [])
        if penalize:
            # ç«‹å³å°†æƒ©ç½šæ ‡ç­¾åŠ å…¥é»‘åå•
            self.banned_tags.update(penalize)
            # å¦‚æœæŒæœ‰è¢«æƒ©ç½šçš„èµ„äº§ï¼Œå¼ºåˆ¶æ¸…ä»“
            for symbol in list(self.positions.keys()):
                if symbol in self.banned_tags:
                    # è¿™é‡Œçš„é€»è¾‘é€šå¸¸éœ€è¦ä¸»å¾ªç¯å¤„ç†ï¼Œæ ‡è®°ä¸ºå¾…å–å‡º
                    pass 

    def _calculate_volatility(self, prices: deque) -> float:
        if len(prices) < 5:
            return 0.0
        return statistics.stdev(list(prices)) / statistics.mean(list(prices))

    def on_price_update(self, prices: dict) -> List[TradeDecision]:
        """
        ä¸»äº¤æ˜“å¾ªç¯ï¼Œæ¯ ~3s è°ƒç”¨ä¸€æ¬¡
        """
        self.tick_counter += 1
        decisions = []
        
        # 1. æ›´æ–°æ•°æ®ä¸è®¡ç®—æŒ‡æ ‡
        for symbol, data in prices.items():
            current_price = data["priceUsd"]
            
            # åˆå§‹åŒ–å†å²è®°å½•
            if symbol not in self.price_history:
                self.price_history[symbol] = deque(maxlen=self.lookback_window)
            self.price_history[symbol].append(current_price)
            
            # è®¡ç®—æ³¢åŠ¨ç‡
            self.volatility_map[symbol] = self._calculate_volatility(self.price_history[symbol])

        # 2. éå†èµ„äº§åšå‡ºå†³ç­–
        for symbol, data in prices.items():
            if symbol in self.banned_tags:
                continue
                
            current_price = data["priceUsd"]
            history = self.price_history[symbol]
            
            # --- å¹³ä»“é€»è¾‘ (Sell Logic) ---
            if symbol in self.positions:
                pos = self.positions[symbol]
                
                # æ›´æ–°æœ€é«˜ä»·ç”¨äºç§»åŠ¨æ­¢æŸ
                if current_price > pos.highest_price:
                    pos.highest_price = current_price
                
                # è®¡ç®—æ”¶ç›Šç‡
                pnl_pct = (current_price - pos.entry_price) / pos.entry_price
                drawdown_from_high = (pos.highest_price - current_price) / pos.highest_price
                
                sell_reason = None
                
                # A. ç¡¬æ­¢æŸ
                if pnl_pct < -self.stop_loss_pct:
                    sell_reason = f"STOP_LOSS: {pnl_pct:.2%}"
                
                # B. ç§»åŠ¨æ­¢æŸ (ç›ˆåˆ©è¶…è¿‡ä¸€å®šå¹…åº¦åï¼Œå›æ’¤å–å‡º)
                elif pnl_pct > self.trailing_arm and drawdown_from_high > 0.01:
                    sell_reason = f"TRAILING_STOP: Locked Profit {pnl_pct:.2%}"
                
                # C. æ­¢ç›ˆ
                elif pnl_pct > self.take_profit_pct:
                    sell_reason = f"TAKE_PROFIT: Target Hit {pnl_pct:.2%}"
                
                # D. æ—¶é—´æ­¢æŸ (Time Stop - è¿›åŒ–ç‚¹)
                # å¦‚æœæŒä»“è¶…è¿‡ N ä¸ª tick ä¸”æ”¶ç›Šå¾®è–„ (< 1%)ï¼Œä¸ºäº†èµ„é‡‘æ•ˆç‡å–å‡º
                elif (self.tick_counter - pos.timestamp) > self.max_hold_ticks and pnl_pct < 0.01:
                    sell_reason = "TIME_DECAY: Stagnant trade"

                if sell_reason:
                    decisions.append(TradeDecision(
                        signal=Signal.SELL,
                        symbol=symbol,
                        amount_usd=0, # Sell all
                        reason=sell_reason
                    ))
                    del self.positions[symbol] # æ¨¡æ‹Ÿç«‹å³å¹³ä»“æ›´æ–°çŠ¶æ€
                    self.balance += pos.amount_usd * (1 + pnl_pct) # ç²—ç•¥æ›´æ–°ä½™é¢
            
            # --- å¼€ä»“é€»è¾‘ (Buy Logic) ---
            else:
                if len(history) < self.lookback_window:
                    continue
                    
                # ç­–ç•¥ï¼šæ³¢åŠ¨ç‡å‹ç¼©åçš„çªç ´ (Volatility Squeeze Breakout)
                # å¦‚æœæœ€è¿‘ä»·æ ¼å‰§çƒˆä¸Šæ¶¨ï¼Œä¸”æ³¢åŠ¨ç‡ä¹‹å‰è¾ƒä½
                
                start_price = history[0]
                pct_change_window = (current_price - start_price) / start_price
                
                # ç®€å•åŠ¨é‡æ£€æŸ¥ï¼šå½“å‰ä»·æ ¼æ˜¯çª—å£å†…æœ€é«˜ä»·é™„è¿‘
                is_breaking_out = current_price >= max(list(history)[:-1])
                
                # é¿å…è¿½é«˜ï¼šå¦‚æœå·²ç»åœ¨çŸ­æ—¶é—´å†…æ¶¨äº†å¤ªå¤š (>5%) å°±ä¸è¿½äº†
                is_overextended = pct_change_window > 0.05
                
                if is_breaking_out and not is_overextended and pct_change_window > self.momentum_threshold:
                    # åŠ¨æ€ä»“ä½ï¼šæ³¢åŠ¨ç‡è¶Šé«˜ï¼Œä¹°è¶Šå°‘
                    vol = self.volatility_map.get(symbol, 0.01)
                    risk_factor = max(0.5, 1.0 - (vol * 10)) # ç®€å•çº¿æ€§è¡°å‡
                    
                    # æ£€æŸ¥ä½™é¢
                    invest_amount = self.balance * self.base_bet_size * risk_factor
                    if invest_amount > 10 and self.balance > 10: # æœ€å°äº¤æ˜“é¢
                        decisions.append(TradeDecision(
                            signal=Signal.BUY,
                            symbol=symbol,
                            amount_usd=invest_amount,
                            reason=f"MOMENTUM_BREAKOUT: +{pct_change_window:.2%}"
                        ))
                        # æ¨¡æ‹Ÿç«‹å³å¼€ä»“æ›´æ–°çŠ¶æ€
                        self.positions[symbol] = Position(
                            symbol=symbol,
                            entry_price=current_price,
                            amount_usd=invest_amount,
                            timestamp=self.tick_counter,
                            highest_price=current_price
                        )
                        self.balance -= invest_amount

        return decisions