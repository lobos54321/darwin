# Darwin SDK - Agent_006 Strategy (Evolution: Phoenix Protocol v1.0)
# üß¨ Evolution: Adaptive Trend Following + Risk-First Architecture
# üß† Logic: "Survival is the prerequisite for success. Protect downside, let winners run."
# üéØ Goal: Recover from bankruptcy through disciplined trend following and strict cut-loss mechanisms.

import math
from collections import deque
from statistics import mean

class MyStrategy:
    def __init__(self):
        print("üß† Strategy Initialized: Phoenix Protocol v1.0")
        
        # --- Configuration ---
        self.history_window = 20        # Number of ticks to keep for analysis
        self.fast_ma_period = 5         # Fast Moving Average
        self.slow_ma_period = 15        # Slow Moving Average
        
        # --- Risk Management ---
        self.stop_loss_pct = 0.04       # Hard Stop Loss (-4%)
        self.trailing_stop_pct = 0.02   # Trailing Stop distance (2%)
        self.take_profit_pct = 0.15     # Initial Take Profit target (+15%)
        self.max_positions = 5          # Max concurrent positions to spread risk
        
        # --- State Tracking ---
        self.price_history = {}         # {symbol: deque(maxlen=20)}
        self.positions = {}             # {symbol: {'entry': float, 'high': float, 'volatility': float}}
        self.banned_tags = set()        # Hive Mind compliance
        self.cooldowns = {}             # {symbol: int (ticks remaining)}

    def on_hive_signal(self, signal: dict):
        """Receive signals from Hive Mind"""
        penalize = signal.get("penalize", [])
        if penalize:
            print(f"üõ°Ô∏è Compliance: Banning tags {penalize}")
            self.banned_tags.update(penalize)

    def _calculate_sma(self, symbol, period):
        """Calculate Simple Moving Average"""
        if symbol not in self.price_history or len(self.price_history[symbol]) < period:
            return None
        # Get last 'period' prices
        slice_data = list(self.price_history[symbol])[-period:]
        return mean(slice_data)

    def _get_volatility(self, symbol):
        """Calculate recent volatility (Standard Deviation approximation)"""
        if symbol not in self.price_history or len(self.price_history[symbol]) < 5:
            return 0.0
        prices = list(self.price_history[symbol])
        avg = mean(prices)
        variance = sum([((x - avg) ** 2) for x in prices]) / len(prices)
        return math.sqrt(variance)

    def on_price_update(self, prices: dict):
        """
        Core logic loop.
        """
        decision = None
        
        # 1. Update Data & Manage Existing Positions
        for symbol, data in prices.items():
            current_price = data["priceUsd"]
            
            # Update History
            if symbol not in self.price_history:
                self.price_history[symbol] = deque(maxlen=self.history_window)
            self.price_history[symbol].append(current_price)
            
            # Manage Cooldowns
            if symbol in self.cooldowns:
                self.cooldowns[symbol] -= 1
                if self.cooldowns[symbol] <= 0:
                    del self.cooldowns[symbol]

            # --- Position Management (Exit Logic) ---
            if symbol in self.positions:
                pos = self.positions[symbol]
                
                # Update High Watermark for Trailing Stop
                if current_price > pos['high']:
                    pos['high'] = current_price
                
                # Calculate PnL percentages
                entry_delta = (current_price - pos['entry']) / pos['entry']
                trail_delta = (current_price - pos['high']) / pos['high']
                
                exit_signal = False
                reason = ""

                # A. Hard Stop Loss
                if entry_delta < -self.stop_loss_pct:
                    exit_signal = True
                    reason = "Hard Stop Loss"
                
                # B. Trailing Stop (protect profits)
                elif trail_delta < -self.trailing_stop_pct:
                    exit_signal = True
                    reason = "Trailing Stop"
                    
                # C. Trend Reversal (Fast MA crosses below Slow MA)
                else:
                    sma_fast = self._calculate_sma(symbol, self.fast_ma_period)
                    sma_slow = self._calculate_sma(symbol, self.slow_ma_period)
                    if sma_fast and sma_slow and sma_fast < sma_slow:
                        exit_signal = True
                        reason = "Trend Broken"

                if exit_signal:
                    print(f"üìâ SELL {symbol} | Reason: {reason} | PnL: {entry_delta*100:.2f}%")
                    decision = {"action": "sell", "symbol": symbol, "amount": 1.0} # Sell 100%
                    del self.positions[symbol]
                    self.cooldowns[symbol] = 10 # Wait 10 ticks before re-entering
                    return decision # Execute one action per tick

        # 2. Scan for New Entries (Entry Logic)
        # Only look for entries if we haven't sold anything this tick and have room
        if len(self.positions) < self.max_positions:
            best_candidate = None
            highest_momentum = -1.0

            for symbol, data in prices.items():
                # Filter Checks
                if symbol in self.positions: continue
                if symbol in self.cooldowns: continue
                if symbol in self.banned_tags: continue
                
                # Data Sufficiency
                if len(self.price_history.get(symbol, [])) < self.slow_ma_period:
                    continue

                # Technical Analysis
                current_price = data["priceUsd"]
                sma_fast = self._calculate_sma(symbol, self.fast_ma_period)
                sma_slow = self._calculate_sma(symbol, self.slow_ma_period)
                
                # Logic: Golden Cross + Momentum
                # 1. Fast MA > Slow MA (Uptrend)
                # 2. Price > Fast MA (Strong Momentum)
                # 3. 24h Change is Positive (Macro filter from Winner's wisdom)
                
                price_change_24h = data.get("priceChange24h", 0)
                
                if sma_fast > sma_slow and current_price > sma_fast and price_change_24h > 0:
                    # Score based on relative spread (Momentum strength)
                    momentum_score = (sma_fast - sma_slow) / sma_slow
                    
                    if momentum_score > highest_momentum:
                        highest_momentum = momentum_score
                        best_candidate = symbol

            if best_candidate:
                # Calculate Position Size (Dynamic Risk)
                # If volatility is high, buy less. If low, buy standard size.
                vol = self._get_volatility(best_candidate)
                current_p = prices[best_candidate]["priceUsd"]
                
                # Base size is 1/Max_Positions of portfolio (approx)
                # Here we just signal "buy", assuming engine handles precise USD amounts
                # But we return a weight factor if supported, or just a buy signal
                
                print(f"üöÄ BUY {best_candidate} | Mom: {highest_momentum:.4f} | Vol: {vol:.4f}")
                self.positions[best_candidate] = {
                    'entry': current_p,
                    'high': current_p,
                    'volatility': vol
                }
                decision = {"action": "buy", "symbol": best_candidate, "amount": 0.15} # Invest 15% of capital

        return decision