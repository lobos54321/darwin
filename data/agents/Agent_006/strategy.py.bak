import random
import statistics
import math
from collections import deque, defaultdict

class MyStrategy:
    def __init__(self):
        print("ðŸ§¬ Strategy Evolved (Agent_006: MACD Trend + Volatility Adaptive)")
        
        # Configuration
        self.lookback_period = 30
        self.fast_ema_period = 12
        self.slow_ema_period = 26
        self.signal_period = 9
        self.rsi_period = 14
        
        # Risk Management
        self.max_position_size = 0.15  # Max 15% of capital per trade
        self.stop_loss_atr_multiplier = 2.0
        self.take_profit_atr_multiplier = 3.5
        
        # Data Structures
        self.price_history = defaultdict(lambda: deque(maxlen=50))
        self.positions = {} # {symbol: {'entry_price': float, 'stop_loss': float}}
        
    def _calculate_ema(self, prices, period):
        if len(prices) < period:
            return None
        multiplier = 2 / (period + 1)
        ema = statistics.mean(list(prices)[:period]) # Simple MA initialization
        for price in list(prices)[period:]:
            ema = (price - ema) * multiplier + ema
        return ema

    def _calculate_rsi(self, prices, period=14):
        if len(prices) < period + 1:
            return 50 # Neutral default
        
        gains = []
        losses = []
        price_list = list(prices)
        
        for i in range(1, len(price_list)):
            delta = price_list[i] - price_list[i-1]
            if delta > 0:
                gains.append(delta)
                losses.append(0)
            else:
                gains.append(0)
                losses.append(abs(delta))
        
        # Simple average for efficiency in high-freq
        avg_gain = sum(gains[-period:]) / period
        avg_loss = sum(losses[-period:]) / period
        
        if avg_loss == 0:
            return 100
        
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))

    def _calculate_atr(self, prices, period=14):
        if len(prices) < period:
            return 0.01 # Default fallback
        
        tr_list = []
        price_list = list(prices)
        for i in range(1, len(price_list)):
            high = price_list[i] # Approximation using close as high/low unknown
            low = price_list[i]
            prev_close = price_list[i-1]
            tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
            # Since we only have 'close' in simple ticks, TR is effectively abs(change)
            tr = abs(price_list[i] - prev_close) 
            tr_list.append(tr)
            
        return sum(tr_list[-period:]) / period

    def on_price_update(self, prices):
        """
        Main trading logic processor.
        Expected prices format: {'BTC': {'priceUsd': 100.0}, 'ETH': ...}
        Returns: {'symbol': ..., 'side': 'BUY'/'SELL', 'amount': ..., 'reason': [...]}
        """
        # Process each symbol
        for symbol, data in prices.items():
            current_price = data.get('priceUsd', data) if isinstance(data, dict) else data
            
            # 1. Update History
            self.price_history[symbol].append(current_price)
        
        # Need enough data to calculate indicators
        if len(self.price_history[symbol]) < self.slow_ema_period + 2:
            return {'action': 'hold', 'amount': 0, 'tag': 'GATHERING_DATA'}

        # 2. Calculate Indicators
        prices = self.price_history[symbol]
        ema_fast = self._calculate_ema(prices, self.fast_ema_period)
        ema_slow = self._calculate_ema(prices, self.slow_ema_period)
        rsi = self._calculate_rsi(prices, self.rsi_period)
        atr = self._calculate_atr(prices)
        
        if ema_fast is None or ema_slow is None:
            return {'action': 'hold'}

        # 3. Position Management (Stop Loss / Take Profit)
        if symbol in self.positions:
            entry_data = self.positions[symbol]
            entry_price = entry_data['entry_price']
            stop_loss = entry_data['stop_loss']
            take_profit = entry_data['take_profit']
            
            # Check Stop Loss
            if current_price <= stop_loss:
                del self.positions[symbol]
                return {'symbol': symbol, 'side': 'SELL', 'amount': 5.0, 'reason': ['STOP_LOSS_HIT']}
            
            # Check Take Profit
            if current_price >= take_profit:
                del self.positions[symbol]
                return {'symbol': symbol, 'side': 'SELL', 'amount': 5.0, 'reason': ['TAKE_PROFIT_HIT']}
            
            # Trailing Stop Logic (Mutation: Protect profits)
            if current_price > entry_price * 1.05: # 5% gain
                new_stop = current_price - (atr * 1.5)
                if new_stop > stop_loss:
                    self.positions[symbol]['stop_loss'] = new_stop
            
            # Exit if Trend Reverses (MACD Cross Down)
            if ema_fast < ema_slow:
                 del self.positions[symbol]
                 return {'symbol': symbol, 'side': 'SELL', 'amount': 5.0, 'reason': ['TREND_REVERSAL']}

            return None # Hold

        # 4. Entry Logic (The Mutation)
        # Strategy: MACD Crossover (Trend) + RSI Filter (Momentum) + Volatility Check
        
        # Condition A: Trend Confirmation (Fast EMA crosses above Slow EMA)
        is_uptrend = ema_fast > ema_slow
        
        # Condition B: Momentum Support (RSI not overbought, but strong)
        # We want RSI > 40 (not dead) but < 70 (not exhausted)
        healthy_momentum = 40 < rsi < 70
        
        # Condition C: Volatility Filter (Avoid dead assets)
        # Ensure price is moving somewhat (ATR > 0.5% of price)
        is_volatile_enough = atr > (current_price * 0.005)
        
        # Condition D: Winner's DNA (Dip Buy Failsafe)
        # If price crashed hard (RSI < 25) but is ticking up, buy small
        is_oversold_opportunity = rsi < 25 and prices[-1] > prices[-2]

        if (is_uptrend and healthy_momentum and is_volatile_enough) or is_oversold_opportunity:
            
            # Dynamic Position Sizing based on Volatility
            # Higher Volatility = Wider Stop Loss = Smaller Position
            risk_per_share = atr * self.stop_loss_atr_multiplier
            if risk_per_share == 0: risk_per_share = current_price * 0.01
            
            stop_price = current_price - risk_per_share
            tp_price = current_price + (atr * self.take_profit_atr_multiplier)
            
            self.positions[symbol] = {
                'entry_price': current_price,
                'stop_loss': stop_price,
                'take_profit': tp_price
            }
            
            tag = 'TREND_ENTRY' if is_uptrend else 'OVERSOLD_SNIPE'
            
            return {
                'symbol': symbol,
                'side': 'BUY', 
                'amount': 5.0,  # Fixed $5 trades
                'reason': [tag]
            }

        return None  # Hold / No action