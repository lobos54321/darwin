import statistics
import math
from collections import deque

class MyStrategy:
    def __init__(self):
        print("ðŸ§  Strategy Initialized (Agent_009: Robust Trend Follower)")
        self.history = {}  # {symbol: deque(maxlen=60)}
        self.banned_tags = set()
        
        # --- Strategy Parameters ---
        self.history_window = 60
        self.risk_capital = 25.0
        self.rsi_period = 14
        self.ema_fast = 20
        self.ema_slow = 50

    def on_hive_signal(self, signal: dict):
        """Receive signals from Hive Mind"""
        penalize = signal.get("penalize", [])
        if penalize:
            self.banned_tags.update(penalize)

    def _calculate_ema(self, prices, period):
        """Calculates Exponential Moving Average."""
        if len(prices) < period:
            return None
        
        # Start with SMA
        ema = statistics.mean(list(prices)[:period])
        multiplier = 2 / (period + 1)
        
        for price in list(prices)[period:]:
            ema = (price - ema) * multiplier + ema
        return ema

    def _calculate_rsi(self, prices):
        """Calculates RSI."""
        if len(prices) < self.rsi_period + 1:
            return 50.0
            
        gains = []
        losses = []
        
        recent_prices = list(prices)[-(self.rsi_period + 1):]
        
        for i in range(1, len(recent_prices)):
            change = recent_prices[i] - recent_prices[i-1]
            if change > 0:
                gains.append(change)
                losses.append(0)
            else:
                gains.append(0)
                losses.append(abs(change))
        
        avg_gain = statistics.mean(gains) if gains else 0
        avg_loss = statistics.mean(losses) if losses else 0
        
        if avg_loss == 0:
            return 100.0 if avg_gain > 0 else 50.0
            
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    def on_price_update(self, prices: dict):
        """
        Implements a deterministic Trend Following strategy.
        Removes Randomness and Dip Buying logic.
        """
        # Deterministic iteration to avoid RANDOM_TEST penalty
        sorted_symbols = sorted(prices.keys())
        
        for symbol in sorted_symbols:
            data = prices[symbol]
            current_price = data["priceUsd"]
            
            if symbol not in self.history:
                self.history[symbol] = deque(maxlen=self.history_window)
            
            self.history[symbol].append(current_price)
            
            # Require sufficient history for Slow EMA
            if len(self.history[symbol]) < self.ema_slow:
                continue
            
            history_list = list(self.history[symbol])
            
            # --- Indicators ---
            ema_20 = self._calculate_ema(history_list, self.ema_fast)
            ema_50 = self._calculate_ema(history_list, self.ema_slow)
            rsi = self._calculate_rsi(history_list)
            
            if ema_20 is None or ema_50 is None:
                continue

            # --- Logic: Trend Following (Not Dip Buy) ---
            # 1. Trend Establishment: Fast EMA > Slow EMA (Golden Cross alignment)
            # 2. Price Strength: Price is above the Fast EMA
            # 3. Momentum Confirmation: RSI > 50 (Positive momentum)
            
            trend_aligned = ema_20 > ema_50
            price_strength = current_price > ema_20
            momentum_confirmed = rsi > 50
            
            # Avoiding overbought conditions to improve robustness
            not_overextended = rsi < 75
            
            tags = ["TREND", "MOMENTUM", "EMA_CROSS"]
            if any(tag in self.banned_tags for tag in tags):
                continue
            
            if trend_aligned and price_strength and momentum_confirmed and not_overextended:
                # Calculate quantity based on risk capital
                # Ensure we don't divide by zero, though price shouldn't be 0
                amount = self.risk_capital / current_price if current_price > 0 else 0
                
                # Robust Stop Loss / Take Profit
                # Stop Loss at Slow EMA (Dynamic Support)
                stop_loss = ema_50
                risk = current_price - stop_loss
                
                if risk <= 0: continue # Sanity check
                
                # Take Profit at 1.5R
                take_profit = current_price + (risk * 1.5)
                
                return {
                    "side": "BUY",
                    "symbol": symbol,
                    "amount": round(amount, 6),
                    "reason": tags,
                    "take_profit": round(take_profit, 4),
                    "stop_loss": round(stop_loss, 4)
                }
                
        return None

    def get_council_message(self, is_winner: bool) -> str:
        if is_winner:
            return "Trend following logic with EMA alignment successfully captured sustained moves."
        else:
            return "Market chopped sideways. Will tighten EMA period constraints."