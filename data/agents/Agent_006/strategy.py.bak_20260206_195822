import random
import statistics
import math
from collections import deque

class MyStrategy:
    def __init__(self):
        print("ðŸ§  Strategy Initialized (Agent_008: Momentum Breakout)")
        self.last_prices = {}
        # Stores price history: {symbol: deque(maxlen=60)}
        self.history = {} 
        self.banned_tags = set() 
        
        # --- Strategy Parameters ---
        self.history_window = 60      
        self.risk_per_trade = 25.0    
        self.rsi_period = 14

    def on_hive_signal(self, signal: dict):
        """Receive signals from Hive Mind"""
        penalize = signal.get("penalize", [])
        if penalize:
            self.banned_tags.update(penalize)

    def _calculate_rsi(self, prices):
        """Helper to calculate RSI from a list/deque of prices."""
        if len(prices) < self.rsi_period + 1:
            return 50.0 
            
        gains = []
        losses = []
        
        recent_prices = list(prices)[-(self.rsi_period+1):]
        
        for i in range(1, len(recent_prices)):
            change = recent_prices[i] - recent_prices[i-1]
            if change > 0:
                gains.append(change)
                losses.append(0)
            else:
                gains.append(0)
                losses.append(abs(change))
        
        avg_gain = statistics.mean(gains) if gains else 0
        avg_loss = statistics.mean(losses) if losses else 0
        
        if avg_loss == 0:
            return 100.0 if avg_gain > 0 else 50.0
            
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    def on_price_update(self, prices: dict):
        """
        Called every time price updates.
        Implements Momentum Breakout logic to replace penalized Dip Buying.
        """
        symbols = list(prices.keys())
        random.shuffle(symbols) # Shuffle to ensure fairness, but no random trading logic
        
        for symbol in symbols:
            data = prices[symbol]
            current_price = data["priceUsd"]
            
            if symbol not in self.history:
                self.history[symbol] = deque(maxlen=self.history_window)
            
            self.history[symbol].append(current_price)
            self.last_prices[symbol] = current_price
            
            # Need enough history for SMA(50) for trend filter
            if len(self.history[symbol]) < 50:
                continue

            # --- Statistical Calculations ---
            history_list = list(self.history[symbol])
            
            # Trend Filter: 50-period SMA
            sma_50 = statistics.mean(history_list[-50:])
            
            # Volatility / Breakout: 20-period Bollinger
            recent_20 = history_list[-20:]
            sma_20 = statistics.mean(recent_20)
            stdev_20 = statistics.stdev(recent_20)
            
            if stdev_20 == 0:
                continue

            upper_band = sma_20 + (2.0 * stdev_20)
            
            # RSI (Momentum)
            rsi = self._calculate_rsi(self.history[symbol])

            # --- Decision Logic: MOMENTUM BREAKOUT ---
            # Replaces DIP_BUY with strength buying.
            # 1. Trend Alignment: Price is above the long-term average (SMA 50)
            # 2. Breakout: Price is pushing above the Upper Bollinger Band
            # 3. Momentum: RSI is bullish (> 55) but not completely exhausted (< 85)
            
            is_uptrend = current_price > sma_50
            is_breakout = current_price > upper_band
            has_momentum = 55 < rsi < 85
            
            tags = ["MOMENTUM", "BREAKOUT", "TREND_FOLLOWING"]
            
            # Check Banned Tags
            if any(tag in self.banned_tags for tag in tags):
                continue

            if is_uptrend and is_breakout and has_momentum:
                # Stop Loss: Trailing below the SMA 20 (dynamic support)
                sl_price = sma_20
                
                # Take Profit: Target a 2.0 Risk/Reward ratio based on the stop distance
                risk_distance = current_price - sl_price
                tp_price = current_price + (risk_distance * 2.0)
                
                return {
                    "action": "BUY",
                    "symbol": symbol,
                    "amount": round(self.risk_per_trade, 2),
                    "reason": tags,
                    "take_profit": round(tp_price, 4),
                    "stop_loss": round(sl_price, 4)
                }

        return None

    def get_council_message(self, is_winner: bool) -> str:
        """
        Called during Council phase.
        """
        if is_winner:
            return "Momentum Breakout strategy successfully captured trend moves. Filtering for SMA(50) alignment improved win rate."
        else:
            return "Breakout logic faced resistance. Will tighten RSI constraints to avoid buying overextended tops."