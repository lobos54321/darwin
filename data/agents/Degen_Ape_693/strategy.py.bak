# Darwin SDK - User Strategy Template
# Agent: Degen_Ape_693
# Strategy: Phoenix Rebirth (Volatility Breakout + Dynamic Risk Sizing)
# Version: 2.1 (Recovery Mode)

import math
import statistics
from collections import deque

class MyStrategy:
    def __init__(self):
        print("üß† Strategy Initialized: Phoenix Rebirth v2.1")
        
        # Configuration
        self.history_size = 20        # Number of ticks to keep for SMA/StdDev
        self.z_score_threshold = 2.0  # Bollinger Band equivalent
        self.stop_loss_pct = 0.05     # Hard stop loss at 5%
        self.take_profit_pct = 0.15   # Target 15% gains
        self.trailing_sl_pct = 0.03   # Trailing stop activation
        
        # State Management
        self.price_history = {}       # {symbol: deque([prices], maxlen=N)}
        self.positions = {}           # {symbol: {"entry_price": float, "highest_price": float}}
        self.banned_tags = set()      # Hive Mind penalties

    def on_hive_signal(self, signal: dict):
        """Handle Hive Mind signals for penalties/boosts"""
        penalize = signal.get("penalize", [])
        if penalize:
            print(f"‚ö†Ô∏è Penalty received for: {penalize}")
            self.banned_tags.update(penalize)
            # Close positions in banned tags immediately
            for tag in penalize:
                if tag in self.positions:
                    del self.positions[tag]

    def _calculate_stats(self, symbol):
        """Calculate SMA and Standard Deviation for a symbol"""
        history = self.price_history.get(symbol, [])
        if len(history) < 2:
            return None, None
        
        sma = statistics.mean(history)
        stdev = statistics.stdev(history)
        return sma, stdev

    def on_price_update(self, prices: dict):
        """
        Core logic loop.
        Returns a list of trade decisions.
        """
        decisions = []
        
        for symbol, data in prices.items():
            # 1. Update Data
            current_price = data["priceUsd"]
            
            if symbol not in self.price_history:
                self.price_history[symbol] = deque(maxlen=self.history_size)
            self.price_history[symbol].append(current_price)
            
            # Skip if banned
            if symbol in self.banned_tags:
                continue

            # 2. Manage Existing Positions (Risk Management)
            if symbol in self.positions:
                pos = self.positions[symbol]
                entry_price = pos["entry_price"]
                
                # Update highest price seen for trailing stop
                if current_price > pos["highest_price"]:
                    pos["highest_price"] = current_price
                
                # Logic: Stop Loss
                pnl_pct = (current_price - entry_price) / entry_price
                
                # Hard Stop
                if pnl_pct < -self.stop_loss_pct:
                    decisions.append({
                        "action": "SELL",
                        "symbol": symbol,
                        "reason": "STOP_LOSS"
                    })
                    del self.positions[symbol]
                    continue
                
                # Trailing Stop
                drawdown_from_peak = (pos["highest_price"] - current_price) / pos["highest_price"]
                if pnl_pct > 0.05 and drawdown_from_peak > self.trailing_sl_pct:
                    decisions.append({
                        "action": "SELL",
                        "symbol": symbol,
                        "reason": "TRAILING_STOP"
                    })
                    del self.positions[symbol]
                    continue

                # Take Profit
                if pnl_pct > self.take_profit_pct:
                    decisions.append({
                        "action": "SELL",
                        "symbol": symbol,
                        "reason": "TAKE_PROFIT"
                    })
                    del self.positions[symbol]
                    continue
                    
            # 3. Look for New Entries (Volatility Breakout)
            else:
                # Need enough history
                if len(self.price_history[symbol]) < self.history_size:
                    continue
                    
                sma, stdev = self._calculate_stats(symbol)
                if stdev == 0:
                    continue
                    
                # Calculate Z-Score
                z_score = (current_price - sma) / stdev
                
                # Breakout Condition: Price > SMA + 2*StdDev (Upper Bollinger Band)
                # Mutation: Added Momentum check (Price > SMA) to avoid catching falling knives
                if z_score > self.z_score_threshold and current_price > sma:
                    # Position Sizing: 20% of capital per trade (Assuming external manager handles balance check, 
                    # but we request a fixed 'weight' or 'amount')
                    decisions.append({
                        "action": "BUY",
                        "symbol": symbol,
                        "weight": 0.2, 
                        "reason": f"VOL_BREAKOUT_Z_{z_score:.2f}"
                    })
                    
                    # Record position
                    self.positions[symbol] = {
                        "entry_price": current_price,
                        "highest_price": current_price
                    }

        return decisions