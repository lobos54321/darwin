```python
# Darwin SDK - User Strategy Template
# üß¨ AGENT: Bo_Bot | GEN: 75 | CODENAME: PHOENIX_ASCENDANT
# -----------------------------------------------------------------------------
# Evolution Log (Gen 75):
# 1. RESET: Discarded complex statistical libraries causing latency/overfitting.
# 2. MUTATION: "Dual-EMA Adaptive Momentum". Uses fast/slow Exponential Moving 
#    Averages to identify trends early, replacing static thresholds.
# 3. DEFENSE: Implemented "High-Water Mark" Trailing Stops. We track the 
#    maximum price seen during a trade and sell if it drops X% from the peak.
# 4. DISCIPLINE: Strict position sizing (max 5 positions, 10% allocation) and
#    post-loss cooldowns to prevent revenge trading.
# -----------------------------------------------------------------------------

import math

class MyStrategy:
    def __init__(self):
        print("üß† Strategy Initialized (Gen 75: Phoenix Ascendant)")
        
        # --- State Management ---
        # holdings: {symbol: {'entry': float, 'high': float}}
        self.holdings = {}           
        # emas: {symbol: {'short': float, 'long': float}}
        self.emas = {}               
        # banned_tags: set of penalized assets
        self.banned_tags = set()     
        # cooldowns: {symbol: int_ticks_remaining}
        self.cooldowns = {}          
        
        # --- Hyperparameters ---
        self.alpha_short = 0.15      # Fast EMA smoothing (Reactive)
        self.alpha_long = 0.05       # Slow EMA smoothing (Trend)
        self.stop_loss_pct = 0.05    # Hard Stop: 5% max loss
        self.trailing_drop = 0.03    # Trailing Stop: Sell if drops 3% from peak
        self.take_profit_pct = 0.20  # Moon Target: 20%
        self.position_size = 0.1     # Allocate 10% of equity per trade
        self.max_positions = 5       # Max concurrent trades
        self.cooldown_ticks = 10     # Ticks to wait after a loss

    def on_hive_signal(self, signal: dict):
        """Absorb Hive Mind signals."""
        penalize = signal.get("penalize", [])
        if penalize:
            print(f"‚ö†Ô∏è Hive Penalty: {penalize}")
            self.banned_tags.update(penalize)
            
        boost = signal.get("boost", [])
        if boost:
            # Forgiveness mechanism for boosted tags
            self.banned_tags.difference_update(boost)

    def _update_ema(self, symbol, price):
        """Updates internal EMA state for trend detection."""
        if symbol not in self.emas:
            self.emas[symbol] = {'short': price, 'long': price}
        else:
            s = self.emas[symbol]['short']
            l = self.emas[symbol]['long']
            # Calculate EMA
            self.emas[symbol]['short'] = (price * self.alpha_short) + (s * (1 - self.alpha_short))
            self.emas[symbol]['long'] = (price * self.alpha_long) + (l * (1 - self.alpha_long))

    def on_price_update(self, prices: dict):
        """
        Core logic loop.
        Expected Return: ("buy", symbol, amount) or ("sell", symbol, amount) or None
        """
        # 1. Manage Cooldowns
        expired = [sym for sym, ticks in self.cooldowns.items() if ticks <= 0]
        for sym in expired:
            del self.cooldowns[sym]
        for sym in self.cooldowns:
            self.cooldowns[sym] -= 1

        decision = None

        # 2. Analyze Market
        for symbol, data in prices.items():
            current_price = data["priceUsd"]
            
            # Update Technical Indicators
            self._update_ema(symbol, current_price)
            
            # --- LOGIC A: POSITION MANAGEMENT (Sell Conditions) ---
            if symbol in self.holdings:
                entry = self.holdings[symbol]['entry']
                high_mark = self.holdings[symbol]['high']
                
                # Update High Water Mark
                if current_price > high_mark:
                    self.holdings[symbol]['high'] = current_price
                    high_mark = current_price
                
                # Calculate Metrics
                pnl_pct = (current_price - entry) / entry
                drawdown_from_high = (high_mark - current_price) / high_mark
                
                