# Darwin SDK - User Strategy Template
# ðŸ§¬ AGENT: Bo_Bot | GEN: 96 | CODENAME: ADAPTIVE_MEAN_REVERSION
# -----------------------------------------------------------------------------
# Evolution Log (Gen 96):
# 1. INHERITANCE: Absorbed Agent_006's "Bollinger Mean Reversion" logic. 
#    Fixed thresholds are dead; Volatility (StdDev) is king.
# 2. MUTATION - "Knife Catcher Protection": Unlike the winner, we do not buy 
#    on the immediate break of the Lower Band. We require a "V-Shape" confirmation 
#    (Price > Previous Price) to ensure the falling knife has hit the floor.
# 3. SURVIVAL - "Dynamic Risk": Stop Loss is no longer static. It is calculated 
#    as 1.5x the current Volatility (StdDev) at entry. Noisy markets get wider stops; 
#    calm markets get tight stops.
# 4. FILTER - "Dead Zone": Added a Minimum Volatility threshold. If bands are too 
#    tight, profit potential < fees. We sit on cash.
# -----------------------------------------------------------------------------

import random
import statistics
import math
from collections import deque

class MyStrategy:
    def __init__(self):
        print("ðŸ§  Strategy Initialized (Gen 96: Adaptive Mean Reversion)")
        
        # --- Configuration ---
        self.HISTORY_WINDOW = 30        # Ticks to calculate Mean/StdDev
        self.MAX_POSITIONS = 5          # Max concurrent trades
        self.POSITION_PCT = 0.18        # 18% equity per trade (leave buffer)
        
        # --- Strategy Parameters ---
        self.BB_STD_DEV = 2.2           # Bollinger Band width (Entry threshold)
        self.MIN_VOLATILITY = 0.003     # Min band width % to justify fees
        self.STOP_LOSS_STD = 1.5        # Stop Loss = Entry - (1.5 * StdDev)
        self.TAKE_PROFIT_STD = 1.0      # Take Profit = Mean (Regression to mean)
        
        # --- State ---
        self.history = {}               # {symbol: deque([prices])}
        self.entry_stats = {}           # {symbol: {entry_price, entry_std, stop_price}}
        self.cooldown = {}              # {symbol: ticks_remaining}

    def get_indicators(self, symbol):
        """Calculates Bollinger Bands and Volatility."""
        prices = self.history[symbol]
        if len(prices) < self.HISTORY_WINDOW:
            return None
        
        # Use recent window
        window = list(prices)[-self.HISTORY_WINDOW:]
        mean = statistics.mean(window)
        stdev = statistics.stdev(window) if len(window) > 1 else 0
        
        return {
            "mean": mean,
            "stdev": stdev,
            "upper": mean + (self.BB_STD_DEV * stdev),
            "lower": mean - (self.BB_STD_DEV * stdev),
            "volatility_pct": (stdev / mean) if mean > 0 else 0
        }

    def next_action(self, state):
        """
        Main tick handler.
        state: {
            'balance': float,
            'portfolio': {'SYMBOL': {'amount': float, 'entry_price': float, ...}},
            'market_prices': {'SYMBOL': float, ...},
            'time': int
        }
        """
        orders = []
        current_balance = state['balance']
        portfolio = state.get('portfolio', {})
        prices = state.get('market_prices', {})
        
        # 1. Update Data & Cooldowns
        for symbol, price in prices.items():
            if symbol not in self.history:
                self.history[symbol] = deque(maxlen=self.HISTORY_WINDOW + 5)
            self.history[symbol].append(price)
            
            if symbol in self.cooldown and self.cooldown[symbol] > 0:
                self.cooldown[symbol] -= 1

        # 2. Manage Existing Positions (Exit Logic)
        for symbol, pos_data in portfolio.items():
            current_price = prices.get(symbol)
            if not current_price: continue
            
            # Retrieve entry stats (or default if missing)
            stats = self.entry_stats.get(symbol, {
                'stop_price': pos_data['entry_price'] * 0.95,
                'target_price': pos_data['entry_price'] * 1.05
            })
            
            indicators = self.get_indicators(symbol)
            
            should_sell = False
            reason = ""

            # A. Dynamic Stop Loss (Volatility Based)
            if current_price <= stats['stop_price']:
                should_sell = True
                reason = "STOP_LOSS"
            
            # B. Mean Reversion Target (Price returned to Mean)
            elif indicators and current_price >= indicators['mean']:
                should_sell = True
                reason = "TAKE_PROFIT_MEAN"
            
            # C. Hard Safety (Prevent total ruin)
            elif current_price < pos_data['entry_price'] * 0.90:
                should_sell = True
                reason = "EMERGENCY_EXIT"

            if should_sell:
                orders.append({'type': 'sell', 'symbol': symbol, 'amount': pos_data['amount']})
                self.cooldown[symbol] = 10  # 10 tick cooldown after exit
                if symbol in self.entry_stats:
                    del self.entry_stats[symbol]

        # 3. Scan for New Entries (Entry Logic)
        # Only if we have capital and slots
        open_slots = self.MAX_POSITIONS - len(portfolio)
        if open_slots > 0 and current_balance > 10:
            
            candidates = []
            
            for symbol, price in prices.items():
                # Skip if in portfolio or cooldown
                if symbol in portfolio or self.cooldown.get(symbol, 0) > 0:
                    continue
                
                indicators = self.get_indicators(symbol)
                if not indicators: continue
                
                # Filter 1: Minimum Volatility (Don't trade flat lines)
                if indicators['volatility_pct'] < self.MIN_VOLATILITY:
                    continue
                
                # Filter 2: Price below Lower Bollinger Band (Oversold)
                is_oversold = price < indicators['lower']
                
                # Filter 3: Confirmation (Price > Previous Price)
                # Prevents catching a falling knife perfectly; waits for 1 tick of bounce
                history_list = list(self.history[symbol])
                if len(history_list) < 2: continue
                prev_price = history_list[-2]
                is_rebounding = price > prev_price

                if is_oversold and is_rebounding:
                    # Score candidate by how oversold it is (Z-Score approximation)
                    z_score = (price - indicators['mean']) / indicators['stdev'] if indicators['stdev'] > 0 else 0
                    candidates.append((symbol, z_score, indicators))

            # Sort by most oversold (lowest negative Z-Score)
            candidates.sort(key=lambda x: x[1])
            
            # Execute Trades
            for symbol, z_score, ind in candidates[:open_slots]:
                # Calculate Position Size
                usd_amount = current_balance * self.POSITION_PCT
                amount = usd_amount / prices[symbol]
                
                # Record Entry Statistics for Risk Management
                self.entry_stats[symbol] = {
                    'entry_price': prices[symbol],
                    'entry_std': ind['stdev'],
                    # Dynamic Stop Loss: Entry minus 1.5 standard deviations
                    'stop_price': prices[symbol] - (self.STOP_LOSS_STD * ind['stdev']),
                    'target_price': ind['mean']
                }
                
                orders.append({'type': 'buy', 'symbol': symbol, 'amount': amount})
                current_balance -= usd_amount # Update virtual balance for loop

        return orders