# Darwin SDK - User Strategy Template
# üß¨ AGENT: Bo_Bot | GEN: 72 | CODENAME: QUANTUM_VELOCITY
# -----------------------------------------------------------------------------
# Evolution Log (Gen 72):
# 1. ANALYSIS: Gen 71 failed due to "Over-fitting" and lack of liquidity management.
# 2. ABSORPTION: Adopted Winner's "Momentum" core but stripped complex indicators.
# 3. MUTATION: "Dynamic Position Sizing" + "Volatility Trailing Stop".
#    - Instead of fixed stops, we use volatility-adjusted exits.
#    - STRICT RULE: Never hold a losing trade > 3 ticks (Time-based Stop).
#    - Focus on "High Velocity" assets (high price change + volume proxy).
# 4. DEFENSE: Max 4 concurrent positions to prevent over-exposure.
# -----------------------------------------------------------------------------

import math
import statistics
from collections import deque

class MyStrategy:
    def __init__(self):
        print("üß† Strategy Initialized (Gen 72: Quantum Velocity)")
        
        # --- Configuration ---
        self.max_positions = 4
        self.trade_size_pct = 0.20  # 20% of capital per trade
        self.min_roi_to_trail = 0.02 # Start trailing after 2% profit
        self.trailing_deviation = 0.015 # 1.5% trailing drop allowed
        self.hard_stop_loss = 0.03 # 3% hard stop
        self.history_len = 12 # Ticks for SMA/Volatility calculation
        
        # --- State ---
        self.balance = 1000.0  # Estimated balance (simulation)
        self.positions = {}    # {symbol: {entry: float, highest: float, amount_usd: float, ticks_held: int}}
        self.price_history = {} # {symbol: deque([prices], maxlen=12)}
        self.banned_tags = set()
        self.tick_counter = 0

    def on_hive_signal(self, signal: dict):
        """React to Hive Mind penalties immediately"""
        penalize = signal.get("penalize", [])
        if penalize:
            print(f"‚ö†Ô∏è HIVE ALERT: Penalizing {penalize}")
            self.banned_tags.update(penalize)
            # Immediate liquidation logic is handled in next price update

    def get_volatility(self, symbol):
        """Calculate simple volatility (std dev / mean)"""
        if symbol not in self.price_history or len(self.price_history[symbol]) < 3:
            return 0.0
        prices = list(self.price_history[symbol])
        mean = statistics.mean(prices)
        if mean == 0: return 0.0
        stdev = statistics.stdev(prices)
        return stdev / mean

    def on_price_update(self, prices: dict):
        """
        Core Logic: Momentum Entry + Volatility Exit
        """
        self.tick_counter += 1
        decision = None
        
        # 1. Update Data & Clean History
        active_symbols = set(prices.keys())
        for symbol, data in prices.items():
            price = data["priceUsd"]
            if symbol not in self.price_history:
                self.price_history[symbol] = deque(maxlen=self.history_len)
            self.price_history[symbol].append(price)

        # 2. Manage Existing Positions (Defense First)
        # Create a list to iterate safely while modifying dictionary
        current_holdings = list(self.positions.keys())
        
        for symbol in current_holdings:
            # Emergency Exit: Symbol delisted or data missing
            if symbol not in prices:
                # Blind sell assumption
                del self.positions[symbol]
                continue
                
            current_price = prices[symbol]["priceUsd"]
            pos = self.positions[symbol]
            pos['ticks_held'] += 1
            
            # Update Highest Price for Trailing Stop
            if current_price > pos['highest']:
                pos['highest'] = current_price
            
            # ROI Calculation
            roi = (current_price - pos['entry']) / pos['entry']
            dd_from_high = (pos['highest'] - current_price) / pos['highest']
            
            should_sell = False
            sell_reason = ""
            
            # A. Hive Ban
            if symbol in self.banned_tags:
                should_sell = True
                sell_reason = "HIVE_BAN"
            
            # B. Hard Stop Loss
            elif roi < -self.hard_stop_loss:
                should_sell = True
                sell_reason = "STOP_LOSS"
                
            # C. Trailing Stop (Active only after profit)
            elif roi > self.min_roi_to_trail and dd_from_high > self.trailing_deviation:
                should_sell = True
                sell_reason = "TRAILING_PROFIT"
                
            # D. Time-Based Stop (Stagnation)
            # If we hold for 5 ticks and are negative or barely break-even, cut it.
            elif pos['ticks_held'] > 5 and roi < 0.005:
                should_sell = True
                sell_reason = "STAGNATION"

            if should_sell:
                # Execute Sell
                proceeds = pos['amount_usd'] * (1 + roi)
                self.balance += proceeds
                print(f"üîª SELL {symbol} | Reason: {sell_reason} | ROI: {roi*100:.2f}%")
                del self.positions[symbol]
                return ("sell", symbol, 1.0) # Sell 100% of position

        # 3. Scan for New Entries (Offense)
        # Only buy if we have slots open and capital available
        if len(self.positions) < self.max_positions and self.balance > 10.0:
            
            best_candidate = None
            best_score = -999.0
            
            for symbol, data in prices.items():
                if symbol in self.positions or symbol in self.banned_tags:
                    continue
                
                price = data["priceUsd"]
                history = self.price_history[symbol]
                
                if len(history) < self.history_len:
                    continue
                    
                # Metrics
                sma = statistics.mean(history)
                volatility = self.get_volatility(symbol)
                
                # Momentum Score: Price vs SMA, adjusted by volatility
                # We want assets moving UP, but not too volatile (pump & dump risk)
                if volatility > 0.10: # Filter out extreme chaos
                    continue
                    
                # Simple Momentum: Current Price > SMA * 1.01 (Breakout)
                if price > sma * 1.005:
                    # Score based on recent velocity
                    velocity = (price - history[-2]) / history[-2]
                    score = velocity / (volatility + 0.001) # Sharpe-like ratio for momentum
                    
                    if score > best_score:
                        best_score = score
                        best_candidate = symbol

            # Execute Buy
            if best_candidate and best_score > 0.5: # Threshold for entry
                amount_to_invest = self.balance * self.trade_size_pct
                entry_price = prices[best_candidate]["priceUsd"]
                
                self.positions[best_candidate] = {
                    'entry': entry_price,
                    'highest': entry_price,
                    'amount_usd': amount_to_invest,
                    'ticks_held': 0
                }
                self.balance -= amount_to_invest
                print(f"üü¢ BUY {best_candidate} | Price: {entry_price} | Score: {best_score:.2f}")
                return ("buy", best_candidate, amount_to_invest)

        return None