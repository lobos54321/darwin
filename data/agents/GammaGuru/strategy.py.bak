# Darwin SDK - User Strategy Template
# ğŸ§  DEVELOPERS: EDIT THIS FILE ONLY!

import math
import statistics
from collections import deque, defaultdict

class MyStrategy:
    def __init__(self):
        print("ğŸ§  Strategy Initialized (GammaGuru v3.0 - Phoenix Mutation)")
        
        # æ ¸å¿ƒé…ç½® (Core Configuration)
        self.window_size = 20          # ç”¨äºè®¡ç®—å‡å€¼å’Œæ³¢åŠ¨ç‡çš„çª—å£
        self.momentum_window = 5       # çŸ­æœŸåŠ¨é‡çª—å£
        self.base_risk_per_trade = 0.15 # æ¯æ¬¡äº¤æ˜“ä½¿ç”¨ä½™é¢çš„ 15%
        self.max_positions = 4         # æœ€å¤§æŒä»“æ•°é‡
        
        # é£é™©æ§åˆ¶ (Risk Management)
        self.hard_stop_loss = 0.08     # 8% å¼ºåˆ¶æ­¢æŸ
        self.trailing_stop_activation = 0.05 # ç›ˆåˆ© 5% åæ¿€æ´»è¿½è¸ªæ­¢æŸ
        self.trailing_stop_distance = 0.03   # 3% å›æ’¤æ­¢ç›ˆ
        
        # æ•°æ®å­˜å‚¨ (Data Storage)
        self.price_history = defaultdict(lambda: deque(maxlen=self.window_size))
        self.holdings = {} # {symbol: {'entry_price': float, 'highest_price': float, 'shares': float}}
        self.banned_tags = set()
        self.boosted_tags = set()
        
        # å†·å´æœºåˆ¶ (Cooldowns)
        self.last_trade_time = {}
        self.cooldown_ticks = 10

    def on_hive_signal(self, signal: dict):
        """å¤„ç† Hive Mind çš„ä¿¡å·"""
        penalize = signal.get("penalize", [])
        if penalize:
            self.banned_tags.update(penalize)
            # ç«‹å³æ¸…ä»“è¢«æƒ©ç½šçš„èµ„äº§
            for tag in penalize:
                if tag in self.holdings:
                    print(f"ğŸš« Emergency Sell: {tag} due to Hive Penalty")
                    # é€»è¾‘ä¸Šè¿™é‡Œåº”è¯¥è§¦å‘å–å‡ºï¼Œå…·ä½“ç”± on_price_update è¿”å›
            
        boost = signal.get("boost", [])
        if boost:
            self.boosted_tags.update(boost)

    def _get_volatility(self, prices):
        """è®¡ç®—ä»·æ ¼çš„æ ‡å‡†å·®ä½œä¸ºæ³¢åŠ¨ç‡æŒ‡æ ‡"""
        if len(prices) < 2:
            return 0.0
        return statistics.stdev(prices)

    def _get_sma(self, prices, n):
        """è®¡ç®—ç®€å•ç§»åŠ¨å¹³å‡"""
        if len(prices) < n:
            return prices[-1]
        return sum(list(prices)[-n:]) / n

    def on_price_update(self, prices: dict):
        """
        æ ¸å¿ƒäº¤æ˜“å¾ªç¯ (3s é—´éš”)
        è¿”å›: dict {"action": "buy"/"sell", "symbol": "...", "amount": ...} æˆ– None
        """
        decisions = []
        
        for symbol, data in prices.items():
            current_price = data["priceUsd"]
            
            # 1. æ›´æ–°å†å²æ•°æ®
            self.price_history[symbol].append(current_price)
            if len(self.price_history[symbol]) < self.momentum_window:
                continue

            # 2. æ£€æŸ¥æŒä»“çŠ¶æ€ (Sell Logic)
            if symbol in self.holdings:
                holding = self.holdings[symbol]
                entry_price = holding['entry_price']
                
                # æ›´æ–°æœ€é«˜ä»·ç”¨äºè¿½è¸ªæ­¢æŸ
                if current_price > holding['highest_price']:
                    holding['highest_price'] = current_price
                
                # è®¡ç®—å½“å‰æ”¶ç›Šç‡
                pnl_pct = (current_price - entry_price) / entry_price
                drawdown_from_high = (holding['highest_price'] - current_price) / holding['highest_price']
                
                should_sell = False
                reason = ""

                # A. å¼ºåˆ¶æ­¢æŸ (Hard Stop)
                if pnl_pct < -self.hard_stop_loss:
                    should_sell = True
                    reason = "Hard Stop Loss"
                
                # B. è¿½è¸ªæ­¢æŸ (Trailing Stop) - ä»…åœ¨ç›ˆåˆ©æ¿€æ´»åç”Ÿæ•ˆ
                elif pnl_pct > self.trailing_stop_activation and drawdown_from_high > self.trailing_stop_distance:
                    should_sell = True
                    reason = "Trailing Stop Hit"
                
                # C. è¶‹åŠ¿åè½¬ (Trend Reversal) - ä»·æ ¼è·Œç ´é•¿å‘¨æœŸå‡çº¿
                elif len(self.price_history[symbol]) >= self.window_size:
                    long_sma = self._get_sma(self.price_history[symbol], self.window_size)
                    if current_price < long_sma * 0.98: # ç»™äºˆ 2% çš„ç¼“å†²
                        should_sell = True
                        reason = "Trend Broken"

                if should_sell:
                    print(f"ğŸ“‰ SELL {symbol}: {reason} (PnL: {pnl_pct*100:.2f}%)")
                    del self.holdings[symbol]
                    return {"action": "sell", "symbol": symbol, "amount": 1.0} # å–å‡ºå…¨éƒ¨

            # 3. æ£€æŸ¥å¼€ä»“æœºä¼š (Buy Logic)
            elif len(self.holdings) < self.max_positions:
                # è¿‡æ»¤è¢«ç¦ç”¨çš„æ ‡ç­¾
                is_banned = False
                for tag in data.get("tags", []):
                    if tag in self.banned_tags:
                        is_banned = True
                        break
                if is_banned: continue

                # å†·å´æœŸæ£€æŸ¥
                # (æ­¤å¤„çœç•¥å…·ä½“çš„æ—¶é—´æˆ³é€»è¾‘ï¼Œç®€åŒ–å¤„ç†)

                history = self.price_history[symbol]
                if len(history) >= self.window_size:
                    # è®¡ç®—æŒ‡æ ‡
                    short_sma = self._get_sma(history, self.momentum_window)
                    long_sma = self._get_sma(history, self.window_size)
                    volatility = self._get_volatility(history)
                    
                    # åŠ¨æ€é˜ˆå€¼ï¼šæ³¢åŠ¨ç‡è¶Šé«˜ï¼Œçªç ´è¦æ±‚è¶Šé«˜
                    breakout_threshold = volatility * 1.5
                    
                    # ç­–ç•¥ï¼šåŠ¨é‡çªç ´ (Momentum Breakout)
                    # 1. çŸ­å‡çº¿ > é•¿å‡çº¿ (è¶‹åŠ¿å‘ä¸Š)
                    # 2. å½“å‰ä»·æ ¼ > é•¿å‡çº¿ + çªç ´é˜ˆå€¼ (ç¡®è®¤çªç ´åŠ›åº¦)
                    # 3. ä»·æ ¼ç›¸æ¯”å‰ä¸€åˆ»ä¸Šæ¶¨ (å³æ—¶åŠ¨é‡)
                    if (short_sma > long_sma and 
                        current_price > (long_sma + breakout_threshold) and
                        current_price > history[-2]):
                        
                        # ä»“ä½ç®¡ç†ï¼šæ³¢åŠ¨ç‡åå‘åŠ æƒ (Volatility Sizing)
                        # æ³¢åŠ¨å¤§ä¹°å¾—å°‘ï¼Œæ³¢åŠ¨å°ä¹°å¾—å¤š
                        vol_factor = 1.0
                        if volatility > 0 and current_price > 0:
                            vol_ratio = volatility / current_price
                            if vol_ratio > 0.05: # é«˜æ³¢åŠ¨ > 5%
                                vol_factor = 0.5
                        
                        # Boost ä¿¡å·åŠ æˆ
                        for tag in data.get("tags", []):
                            if tag in self.boosted_tags:
                                vol_factor *= 1.2
                        
                        print(f"ğŸš€ BUY {symbol}: Breakout detected (Vol Factor: {vol_factor:.2f})")
                        
                        # è®°å½•æŒä»“
                        self.holdings[symbol] = {
                            'entry_price': current_price,
                            'highest_price': current_price,
                            'shares': 0 # å…·ä½“æ•°é‡ç”±å¼•æ“å†³å®šï¼Œè¿™é‡Œåªåšé€»è¾‘è®°å½•
                        }
                        
                        return {
                            "action": "buy", 
                            "symbol": symbol, 
                            "amount": self.base_risk_per_trade * vol_factor
                        }

        return None