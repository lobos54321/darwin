{
  "version": 0,
  "epoch": 0,
  "timestamp": "2026-02-12T06:49:52.957662",
  "strategy_code": "import math\nfrom collections import deque\n\nclass MyStrategy:\n    def __init__(self):\n        # --- Configuration ---\n        self.window_size = 20\n        self.max_positions = 5\n        self.trade_size_usd = 2000.0\n        self.min_liquidity = 3_000_000.0  # Filter for liquid pairs\n        \n        # --- Breakout & Momentum Logic ---\n        # Instead of dip buying, we target 'Smooth Breakouts'.\n        # We look for high linear regression slope (velocity) combined with \n        # high R-squared (consistency).\n        self.min_slope = 0.0004       # Min log-price growth per tick\n        self.min_r_squared = 0.75     # Min correlation (trend smoothness)\n        \n        # --- Risk Management ---\n        self.stop_loss_pct = 0.02     # Hard Stop 2%\n        self.trailing_arm_pct = 0.01  # Profit needed to arm trailing stop\n        self.trailing_dist_pct = 0.005 # Trailing distance 0.5%\n        self.max_hold_ticks = 40      # Rotate capital quickly\n        \n        # --- State ---\n        self.history = {}\n        self.positions = {}\n        self.tick_count = 0\n\n    def get_trend_stats(self, prices):\n        \"\"\"\n        Calculates the Linear Regression Slope and R-Squared of Log(Prices).\n        High Slope + High R2 = Strong, Clean Momentum.\n        \"\"\"\n        n = len(prices)\n        if n < 5: return 0.0, 0.0\n        \n        x_vals = list(range(n))\n        y_vals = [math.log(p) for p in prices]\n        \n        sum_x = sum(x_vals)\n        sum_y = sum(y_vals)\n        sum_xy = sum(x * y for x, y in zip(x_vals, y_vals))\n        sum_xx = sum(x * x for x in x_vals)\n        \n        # Calculate Slope (m)\n        numerator = (n * sum_xy) - (sum_x * sum_y)\n        denominator = (n * sum_xx) - (sum_x * sum_x)\n        \n        if denominator == 0: return 0.0, 0.0\n        slope = numerator / denominator\n        \n        # Calculate Intercept (b)\n        intercept = (sum_y - slope * sum_x) / n\n        \n        # Calculate R-Squared\n        y_pred = [slope * x + intercept for x in x_vals]\n        mean_y = sum_y / n\n        ss_tot = sum((y - mean_y) ** 2 for y in y_vals)\n        ss_res = sum((y - yp) ** 2 for y, yp in zip(y_vals, y_pred))\n        \n        if ss_tot == 0: return slope, 0.0\n        r_squared = 1 - (ss_res / ss_tot)\n        \n        return slope, r_squared\n\n    def on_price_update(self, prices):\n        self.tick_count += 1\n        \n        # 1. Prune & Update History\n        current_symbols = set(prices.keys())\n        for s in list(self.history.keys()):\n            if s not in current_symbols:\n                del self.history[s]\n                \n        for s, data in prices.items():\n            if s not in self.history:\n                self.history[s] = deque(maxlen=self.window_size)\n            self.history[s].append(data['priceUsd'])\n\n        # 2. Position Management (Exits)\n        active_symbols = list(self.positions.keys())\n        for symbol in active_symbols:\n            if symbol not in prices: continue\n            \n            pos = self.positions[symbol]\n            current_price = prices[symbol]['priceUsd']\n            entry_price = pos['entry_price']\n            \n            # Update High Water Mark\n            if current_price > pos['high_water_mark']:\n                pos['high_water_mark'] = current_price\n            \n            roi = (current_price - entry_price) / entry_price\n            dd_from_top = (current_price - pos['high_water_mark']) / pos['high_water_mark']\n            \n            exit_reason = None\n            \n            # Stop Loss (Catastrophic protection)\n            if roi <= -self.stop_loss_pct:\n                exit_reason = 'STOP_LOSS'\n            \n            # Trailing Stop\n            # Only active if we are/were in profit > arming pct\n            elif (pos['high_water_mark'] / entry_price) - 1 >= self.trailing_arm_pct:\n                if dd_from_top <= -self.trailing_dist_pct:\n                    exit_reason = 'TRAILING_STOP'\n            \n            # Time Decay Exit\n            elif self.tick_count - pos['entry_tick'] >= self.max_hold_ticks:\n                exit_reason = 'TIMEOUT'\n            \n            if exit_reason:\n                amount = pos['amount']\n                del self.positions[symbol]\n                return {\n                    'side': 'SELL',\n                    'symbol': symbol,\n                    'amount': amount,\n                    'reason': [exit_reason]\n                }\n\n        # 3. Entry Logic (Scan)\n        if len(self.positions) >= self.max_positions:\n            return None\n        \n        # Filter: High Liquidity Only\n        candidates = [s for s, d in prices.items() if d['liquidity'] >= self.min_liquidity]\n        \n        # Sort: Prioritize assets with highest 24h Change (Trend Following)\n        # This naturally pushes us away from \"Dip Buying\" towards \"Strength Buying\".\n        candidates.sort(key=lambda s: prices[s]['priceChange24h'], reverse=True)\n        \n        for symbol in candidates:\n            if symbol in self.positions: continue\n            \n            hist = self.history[symbol]\n            if len(hist) < self.window_size: continue\n            \n            price_list = list(hist)\n            current_price = price_list[-1]\n            \n            # --- Anti-Penalty Logic ---\n            # To fix DIP_BUY, we strictly buy BREAKOUTS.\n            # Condition 1: Current Price must be >= Highest price of previous (N-1) ticks.\n            # This is a Donchian Channel Breakout logic.\n            past_prices = price_list[:-1]\n            local_high = max(past_prices)\n            \n            if current_price < local_high:\n                # Not a breakout -> Skip\n                continue\n                \n            # Condition 2: Smooth Momentum (Slope & R2)\n            slope, r2 = self.get_trend_stats(price_list)\n            \n            if slope >= self.min_slope and r2 >= self.min_r_squared:\n                \n                # Condition 3: Positive Volume Confirmation (Optional but good)\n                # Ensure 24h change is positive\n                if prices[symbol]['priceChange24h'] > 0:\n                \n                    amount = self.trade_size_usd / current_price\n                    self.positions[symbol] = {\n                        'entry_price': current_price,\n                        'high_water_mark': current_price,\n                        'amount': amount,\n                        'entry_tick': self.tick_count\n                    }\n                    \n                    return {\n                        'side': 'BUY',\n                        'symbol': symbol,\n                        'amount': amount,\n                        'reason': ['BREAKOUT_MOMENTUM', f'SLOPE_{slope:.5f}']\n                    }\n\n        return None",
  "hive_data": {
    "boost": [],
    "penalize": [],
    "alpha_factors": {}
  },
  "performance": {
    "avg_pnl": 0.0,
    "win_rate": 0.0,
    "sharpe_ratio": 0.0
  },
  "source": "initial_agent_001"
}